#+TITLE: Emacs Setup History
#+AUTHOR: Tony aldon
#+DATE: <2021-03-15 Mon>

* About
This document contains the *history* of my [[https://github.com/tonyaldon/emacs.d][emacs setup]].  It is a kind of
/autobiography/ of my *emacs* /journey/.
* Motivation
I /need/ to know how I *end up* with the [[https://github.com/tonyaldon/emacs.d][emacs setup]] I'm using now.  *Emacs*
is so /versatile/ and /powerful/ that you can easily /getting lost bowels/.

This document *main goal* is to give me more *visibility* on my /setup/.

This should give me more /confidence/.  And maybe I'll *get rid of* lot
/unused/ and  /unnecessary/ code.  *WHO KNOWS?*
* Step 13 (January 29, 2021 - March 15, 2021)
commit 2d27690620cf4d59b93952f0f666db417ca84941 (v4.0.0)

I used emacs 28.50.

I gathered a few *handy* commands I'm using daily that suits my style of
programming in my custom package ~handy~.  These commands are mostly used:
1. to operate on lines,
2. to operate on sexp,
3. and to mark things.

I also focused my attention on the way I mark things (select things).
I updated and added new marking commands that are in ~handy~ package.  And
I also wrote a new custom mode ~region-active-spc-mode~ that brings a
really new way of modifying an active region (a selection).  When
~region-active-spc-mode~ is turned on, this changes the way
~self-insert-command~ (and other /insert commands/) works.  For instance,
with the stantard setup, when a region is active and you type ~b~, the
command ~backward-word~ is called instead of inserting the character ~b~,
which *speed* marking (selecting) operations.

As ~emacs~ seems endless, I felt the need to write this history of my
emacs setup.  I started writting this history on wednesday 17
February, 2021.

** Discarded Packages (in the setup)
I no longer use ~pending-delete-mode~ because it is in conflict with my
new custom mode ~region-active-spc-mode~.

| packages/modes      | links    |
|---------------------+----------|
| ~pending-delete-mode~ | built-in |
** Discarded commands (in the setup)
| commands                         | links    |
|----------------------------------+----------|
| ta-mark-end-of-line              | custom   |
| ta-jsx-comment-or-uncomment-line | custom   |
| ta-avy-mark-region               | custom   |
| ta-avy-kill-yank-whole-line      | custom   |
| ta-avy-kill-sexp                 | custom   |
| cleanup-buffer                   | custom   |
| zap-up-to-char                   | built-in |
| goto-line                        | built-in |
| swiper                           | [[https://github.com/abo-abo/swiper][ivy]]      |
| avy-copy-line                    | [[https://github.com/abo-abo/avy][avy]]      |
** New Packages (in the setup)
| packages/modes       | links                |
|----------------------+----------------------|
| info-colors          | [[https://github.com/ubolonton/info-colors][info-colors]]          |
** Custom commands
*** in ~linux.el~

#+BEGIN_SRC emacs-lisp
(defun linux-switch-keyboard-layout ()
  "Switch keyboard layout variant between\"takbl\" and \"takbl fr\"."
  (interactive)
  (let ((variant (shell-command-to-string "setxkbmap -query | grep variant | awk -F' '  '{ print $2 }'")))
    (cond ((string= variant "")
           (shell-command-to-string "setxkbmap -layout takbl -variant fr")
           (message "takbl - fr"))
          ((string= variant "fr\n")
           (shell-command-to-string "setxkbmap -layout takbl -variant es")
           (message "takbl - es"))
          ((string= variant "es\n")
           (shell-command-to-string "setxkbmap -layout takbl")
           (message "takbl")))))
#+END_SRC

** Custom modes
*** region-active-spc.el

#+BEGIN_SRC emacs-lisp
;;; About

;; When `region-active-spc-mode' is turned on, this modify some
;; typed character (self-insert-command) when the `region-active-p' is
;; true and instead of inserting the typed character it trigger any
;; command you set in `region-active-spc-map' variable.
;;
;; With the stantard setup, when a region is active and you type "b",
;; the command `backward-word' is call instead of inserting character
;; "b".
;;
;; "spc" in `region-active-spc-mode' means SPeed Command.
;;
;; `region-active-spc-mode' mode is incompatible with
;; `pending-delete-mode' alias of `delete-selection-mode'.

;;; Code

(defvar region-active-spc-exchange-p t
  "If set to t, exchange `point' and `mark' before moving point
under certain conditions.

Consider the following event sequence:
1. you call a command in `region-active-spc-mark-commands',
2. this set the mark and the point (we assume that point is less
   than mark),
3. now you call a command in `region-active-spc-map',
4. if the command would have make the point greater than
   the mark (and so belong to `region-active-spc-forward-commands'),
   we exchange the point and mark before running the command
  (if `region-active-spc-exchange-p' is set to t).

See: `region-active-spc-exchange-point-and-mark'.")

(defvar region-active-spc-mark-commands
  '(handy-expand-region-dwim
    handy-mark-dwim
    handy-mark-inside-dwim
    handy-mark-line
    mark-paragraph)
  "List of mouvement commands that move the cursor backward.")

(defvar region-active-spc-backward-commands
  '(backward-word
    previous-logical-line
    sp-backward-sexp
    beginning-of-line
    backward-paragraph)
  "List of mouvement commands that move the cursor backward.")

(defvar region-active-spc-forward-commands
  '(forward-word
    next-logical-line
    sp-forward-sexp
    end-of-line
    forward-paragraph)
  "List of mouvement commands that move the cursor forward.")

(defvar region-active-spc-self-insert-commands
  '(self-insert-command
    org-self-insert-command
    outline-spc-self-insert-command)
  "List of command like `self-insert-command' we want to
advice \":before-until\" with `region-active-spc-trigger'.")

(defvar region-active-spc-map
  '(("." . narrow-to-region)
    (":" . eval-region)
    ("," . kill-region)
    ("c" . kill-ring-save)
    ("q" . backward-delete-char-untabify)
    ("t" . exchange-point-and-mark)
    ("p" . previous-logical-line)
    ("n" . next-logical-line)
    ("b" . backward-word)
    ("f" . forward-word)
    ("u" . sp-backward-sexp)
    ("i" . sp-forward-sexp)
    ("a" . beginning-of-line)
    ("e" . end-of-line)
    ("y" . backward-paragraph)
    ("x" . forward-paragraph))
  "Alist of speed commands.
The car of each entry is a string with a single letter, which must
be assigned to `self-insert-command' in the global map.
The cdr is either a command to be called interactively.")

(defun region-active-spc-trigger (&rest r)
  "When region is active, trigger a command instead of inserting
the character if it is mapped to a command in `region-active-spc-map'.

Function intended to be used as advice \":before-until\" of
any command like `self-insert-command'."
  (if (region-active-p)
      (let* ((key-vector (this-command-keys-vector))
             (key-string (make-string 1 (aref key-vector 0)))
             (speed-command
              (cdr (assoc key-string region-active-spc-map))))
        (when speed-command
          (setq this-command speed-command)
          (call-interactively speed-command) t))))

(defun point-<-mark-p ()
  "Return t if `point' is less than `mark'."
  (< (point) (mark)))

(defun region-active-spc-exchange-point-and-mark (&rest r)
  "Exchange `point' and `mark' if the cursor movement
would have change the order between `point' and `mark', but only
the first time after having marked a thing with a command in
`region-active-spc-mark-commands'."
  (when (and (region-active-p)
             (-contains-p region-active-spc-mark-commands last-command))
    (cond
     ((and (point-<-mark-p)
           (-contains-p region-active-spc-forward-commands this-command))
      (exchange-point-and-mark))
     ((and (not (point-<-mark-p))
           (-contains-p region-active-spc-backward-commands this-command))
      (exchange-point-and-mark))
     (t nil))))

;;; region-active-spc-mode

(defvar region-active-spc-delete-selection-mode-user nil)

(define-minor-mode region-active-spc-mode
  "Toggle `region-active-spc-mode' mode on or off."
  :global nil
  (if region-active-spc-mode
      (progn
        (--each region-active-spc-self-insert-commands
          (advice-add it :before-until 'region-active-spc-trigger))
        (--each (append region-active-spc-backward-commands
                        region-active-spc-forward-commands)
          (advice-add it :before 'region-active-spc-exchange-point-and-mark))
        (when (boundp delete-selection-mode)
          (setq region-active-spc-delete-selection-mode-user
                delete-selection-mode)
          (delete-selection-mode -1)))
    (--each region-active-spc-self-insert-commands
      (advice-remove it 'region-active-spc-trigger))
    (--each (append region-active-spc-backward-commands
                    region-active-spc-forward-commands)
      (advice-remove it 'region-active-spc-exchange-point-and-mark))
    (when region-active-spc-delete-selection-mode-user
      (delete-selection-mode t)
      (setq region-active-spc-delete-selection-mode-user nil))))

;;; Comments

(comment ; when, call-interactively, assoc, type-of
 (when nil "uie")
 (when t "uie" "uieee")

 (equal t (call-interactively 'next-line)) ; nil
 (assoc "a" '(("a" . jim) ("b" . tony))) ; ("a" . jim)
 (assoc "c" '(("a" . jim) ("b" . tony))) ; nil

 (call-interactively nil) ; error
 (call-interactively
  (cdr (assoc "n" '(("n" . next-line) ("p" . previous-line)))))
 (call-interactively
  (cdr (assoc "x" '(("n" . next-line) ("p" . previous-line))))) ; error

 (type-of (cdr (assoc "n" '(("n" . next-line) ("p" . previous-line))))) ; symbol

 (let ((_a '(a b c)))
   (append _a '(d e))
   _a) ; (a b c)

 )

(comment ; vectorp, this-command-keys-vector, make-string, aref, symbol-name
 (vectorp (this-command-keys-vector)) ; t
 (vectorp (make-string 2 (aref (this-command-keys-vector) 0))) ; error
 (vectorp (make-string 2 (symbol-name (aref (this-command-keys-vector) 0)))) ; error
 (type-of (aref (this-command-keys-vector) 0)) ; symbol
 (make-string 1 'a) ; error
 (symbol-name 'a) ; "a"
 )

(comment ; read-key-sequence-vector, num-input-keys, this-command-keys-vector
 ;; (info "(elisp) Key Sequence Input")
 (let ((dot (read-key-sequence-vector "type a dot:")))
   ;; (equal [46] dot)
   (equal [?.] dot))
 (read-key-sequence-vector nil)
 (read-key-sequence-vector "type key")
 (read-key-sequence "type key")
 num-input-keys
 (this-command-keys-vector)
 (advice-remove 'self-insert-command 'region-active-spc-trigger)
 (advice-remove 'org-self-insert-command 'region-active-spc-trigger)
 (advice-remove 'outline-spc-self-insert-command 'region-active-spc-trigger)
 )

;;; Footer

(provide 'region-active-spc)

#+END_SRC
*** rename
I rename and refactor ~outline-speed-commands.el~ to ~outline-spc.el~.

#+BEGIN_SRC emacs-lisp
;;; About

;; `outline-spc' (SPeed Commands) brings speed commands capability
;; to any major-mode with `outline-minor-mode' turned on.  To use
;; it, you just have to turn on the minor mode `outline-spc-mode'.
;; Then when you are at the beginning of an outline defined in
;; `outline-regexp', typing a single key where the mapping is
;; defined either in `outline-spc-user' or
;; `outline-spc-default'variables, trigger an outline
;; commands instead of inserting the character typed.  For instance,
;; by default, if you are at the beginning of an outline and you
;; type "n", this call `outline-next-visible-heading' command.

;;; Packages

(require 'outline)

;;; The self insert command

(defun outline-spc-self-insert-command (N)
  "Like `self-insert-command' but allow speed commands

define in `outline-spc-default' and `outline-spc-user'
when the cursor is at the beginning of an outline headline.

This is a ligth adaptation of `org-self-insert-command'."
  (interactive "p")
  (cond
   ((and outline-spc-mode
         (let ((kv (this-command-keys-vector)))
           (setq outline-spc-speed-command
                 (run-hook-with-args-until-success
                  'outline-spc-hook
                  (make-string 1 (aref kv (1- (length kv))))))))
    (cond
     ((commandp outline-spc-speed-command)
      (setq this-command outline-spc-speed-command)
      (call-interactively outline-spc-speed-command))
     ((functionp outline-spc-speed-command)
      (funcall outline-spc-speed-command))
     ((and outline-spc-speed-command (listp outline-spc-speed-command))
      (eval outline-spc-speed-command))
     (t (call-interactively 'outline-spc-self-insert-command))))
   (t
    (setq this-command 'self-insert-command)
    (self-insert-command N))))


;;; Speed keys

(defvar outline-spc-user nil
  "Alist of additional speed commands.
This list will be checked before `outline-spc-default'.
when the cursor is at the beginning of a headline.
The car of each entry is a string with a single letter, which must
be assigned to `self-insert-command' in the global map.
The cdr is either a command to be called interactively, a function
to be called, or a form to be evaluated.
An entry that is just a list with a single string will be interpreted
as a descriptive headline that will be added when listing the speed
commands in the Help buffer using the `?' speed command.")

(defvar outline-spc-hook '(outline-spc-activate)
  "Hook for activating speed commands at strategic locations.
Hook functions are called in sequence until a valid handler is
found.

Each hook takes a single argument, a user-pressed command key
which is also a `self-insert-command' from the global map.

Within the hook, examine the cursor position and the command key
and return nil or a valid handler as appropriate.  Handler could
be one of an interactive command, a function, or a form.

Turn on `outline-spc-mode' to enable this hook.")

(defconst outline-spc-default
  '(("Outline Navigation")
    ("n" . (outline-spc-move-safe 'outline-next-visible-heading))
    ("p" . (outline-spc-move-safe 'outline-previous-visible-heading))
    ("f" . (outline-spc-move-safe 'outline-forward-same-level))
    ("b" . (outline-spc-move-safe 'outline-backward-same-level))
    ("u" . (outline-spc-move-safe 'outline-up-heading))
    ("Outline Visibility")
    ("i" . outline-show-children)
    ("s" . outline-show-subtree)
    ("d" . outline-hide-subtree)
    ("t" . outline-hide-body)
    ("a" . outline-show-all)
    ("c" . outline-hide-entry)
    ("e" . outline-show-entry)
    ("l" . outline-hide-leaves)
    ("k" . outline-show-branches)
    ("q" . outline-hide-sublevels)
    ("o" . outline-hide-other)
    ("Outline Structure Editing")
    ("@" . outline-mark-subtree)
    ("^". outline-move-subtree-up)
    ("v". outline-move-subtree-down)
    ("<". outline-promote)
    (">". outline-demote)
    ("m". outline-insert-heading)
    "The default Outline speed commands."))

(defun outline-spc-move-safe (cmd)
  "Execute CMD, but make sure that the cursor always ends up in a headline.
If not, return to the original position and throw an error."
  (interactive)
  (let ((pos (point)))
    (call-interactively cmd)
    (unless (and (bolp) (outline-on-heading-p t))
      (goto-char pos)
      (error "Boundary reached while executing %s" cmd))))

(defun outline-spc-activate (keys)
  "Hook for activating single-letter speed commands.
`outline-spc-default' specifies a minimal command set.
Use `outline-spc-user' for further customization."
  (when (and (bolp) (looking-at outline-regexp))
    (cdr (assoc keys (append outline-spc-user
                             outline-spc-default)))))

;;; outline-spc-mode

(define-minor-mode outline-spc-mode
  "Toggle `outline-spc-mode' mode on or off."
  :global nil
  (if outline-spc-mode
      (local-set-key [remap self-insert-command]
                     'outline-spc-self-insert-command)
    (local-set-key [remap self-insert-command] nil)))


;;; Footer

(provide 'outline-spc)

#+END_SRC

** Custom packages

#+BEGIN_SRC emacs-lisp
;;; About

;; A few HANDY commands I'm using daily that suits my style of
;; programming.
;;
;; These commands are mostly used:
;;   1. to operate on lines,
;;   2. to operate on sexp,
;;   3. and to mark things.

;;; Declare functions

(declare-function avy-goto-word-or-subword-1 "ext:avy")

(declare-function sp-transpose-sexp "ext:smartparens")
(declare-function sp-backward-sexp "ext:smartparens")
(declare-function sp-forward-sexp "ext:smartparens")
(declare-function sp-previous-sexp "ext:smartparens")
(declare-function sp-get-thing "ext:smartparens")
(declare-function sp-get "ext:smartparens")
(declare-function sp-backward-up-sexp "ext:smartparens")
(declare-function sp-backward-down-sexp "ext:smartparens")
(declare-function sp-mark-sexp "ext:smartparens")
(declare-function sp-down-sexp "ext:smartparens")

(declare-function er/expand-region "ext:expand-region")
(declare-function er/mark-word "ext:expand-region")
(declare-function er/mark-sentence "ext:expand-region")
(declare-function er/mark-url "ext:expand-region")
(declare-function er--point-inside-string-p "ext:expand-region")
(declare-function er/mark-inside-quotes "ext:expand-region")

(declare-function org-table-beginning-of-field "org")
(declare-function org-at-table-p "ext:smartparens")

;;; Operate on lines

(defun handy-line-kill ()
  "Kill the whole current line."
  (interactive)
  (let ((column-position (current-column)))
    (kill-whole-line)
    (move-to-column column-position)))

(defun handy-line-copy ()
  "Copy current line."
  (interactive)
  (copy-region-as-kill (point-at-bol) (point-at-eol)))

(defun handy-line-copy-paste-below ()
  "Copy current line and past it below "
  (interactive)
  (let ((init-point (point))
        (line (buffer-substring-no-properties (point-at-bol) (point-at-eol))))
    (save-excursion
      (next-line)
      (beginning-of-line)
      (insert (s-concat line "\n")))))

(defun handy-line-comment ()
  "Comment or uncomment the current line.

See `comment-or-uncomment-region'."
  (interactive)
  (comment-or-uncomment-region (point-at-bol) (point-at-eol)))

(defun handy-line-add-above ()
  "Add an empty line above and move the cursor to this line."
  (interactive)
  (back-to-indentation)
  (split-line))

(defun handy-line-add-below ()
  "Add an empty line below and move the cursor to this line."
  (interactive)
  (end-of-line)
  (newline-and-indent))

;;; Operate on sexps

(defun handy-sp-touch ()
  "Indicate if cursor is \"touching\" the right or the left of a sp-sexp.

If the cursor touches the right of a sp-sexp, return symbol 'right.
If the cursor touches the left of a sp-sexp, return symbol 'left.
If the cursor is strickly inside a symbol 'symbol.
If the cursor doesn't touch any sp-sexp, return nil."
  (let ((beg-of-next-thing (plist-get (sp-get-thing) :beg))
        (end-of-prev-thing (plist-get (sp-get-thing t) :end)))
    (cond ((equal (point) beg-of-next-thing) 'left)
          ((equal (point) end-of-prev-thing) 'right)
          ((< end-of-prev-thing (point) beg-of-next-thing) nil)
          (t 'symbol))))

(defun handy-sp-drag-backward ()
  "Drag sp-sexp at point backward."
  (interactive)
  (let ((delta (- (point) (plist-get (sp-get-thing) :beg))))
    (cond
     ((equal (handy-sp-touch) 'left)
      (sp-transpose-sexp)
      (sp-backward-sexp 2))
     ((equal (handy-sp-touch) 'right)
      (sp-backward-sexp)
      (sp-transpose-sexp)
      (sp-previous-sexp))
     ((equal (handy-sp-touch) 'symbol)
      (sp-backward-sexp)
      (sp-transpose-sexp)
      (sp-backward-sexp 2)
      (forward-char delta)))))

(defun handy-sp-drag-forward ()
  "Drag next sexp to the left of the previous sexp."
  (interactive)
  (let ((delta (- (point) (plist-get (sp-get-thing) :beg))))
    (cond
     ((equal (handy-sp-touch) 'left)
      (sp-forward-sexp)
      (sp-transpose-sexp)
      (sp-backward-sexp))
     ((equal (handy-sp-touch) 'right)
      (sp-transpose-sexp))
     ((equal (handy-sp-touch) 'symbol)
      (sp-forward-sexp)
      (sp-transpose-sexp)
      (sp-backward-sexp)
      (forward-char delta)))))

(defun handy-avy-copy-past-sexp ()
  "Past sexp copied using `avy' at current cursor position."
  (interactive)
  (let ((initial-window (selected-window)))
    (save-excursion
      (call-interactively 'avy-goto-word-or-subword-1)
      (sp-copy-sexp))
    (select-window initial-window)
    (yank)))

;;; Mark things

(defun handy-mark-pop-local ()
  (interactive)
  (set-mark-command t))

(defun handy-point-in-string-p (pt)
  "Returns t if PT is in a string"
  (eq 'string (syntax-ppss-context (syntax-ppss pt))))

(defun handy-point-in-url-p ()
  "Return the url at `point' if `point' is in an url."
  (thing-at-point 'url))

(defun handy-point-at-beginning-of-sexp-delimited-by-pairs-p ()
  "Return t if point is at beginning of sexp delimited by pairs."
  (let ((sexp (sp-get-thing)))
    (and (eq (point) (sp-get sexp :beg))
         (not (string-empty-p (sp-get sexp :op))))))

(defun handy-mark-goto-beginning-of-string (pt)
  "Go to begining of the string if PT is inside a string.

Return nil if PT isn't inside a string.
See the function `handy-point-in-string-p'"
  (if (handy-point-in-string-p pt)
      (goto-char (nth 8 (syntax-ppss pt)))
    nil))

(defun handy-mark-line (arg)
  "Mark the current line.

If call with `universal-argument', copy the line."
  (interactive "p")
  (if (equal arg 4)
      (handy-line-copy)
    ;; HACK: Have to use both `push-mark' and `set-mark' in this order
    ;;       to get expected result.
    (end-of-line)
    (push-mark (point))
    (set-mark (point))
    (beginning-of-line)))

(defun handy-mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    ;; HACK: Have to use both `push-mark' and `set-mark' in this order to
    ;;       expected result.
    (push-mark sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun handy-mark-inside-pairs ()
  "An other way to do `er/mark-inside-pairs' but work for sgml-tag too."
  (interactive)
  (handy-mark-goto-beginning-of-string (point))
  ;; todo: do thing when inside a tag <tag name="tony"> (maybe use the function sgml-begining-of-tag)
  (sp-backward-up-sexp)
  (sp-mark-sexp)
  (sp-down-sexp)
  (exchange-point-and-mark)
  (sp-backward-down-sexp)
  (exchange-point-and-mark))

(defun handy-mark-inside-field ()
  "Mark current field inside org-table."
  (interactive)
  (when (org-at-table-p)
    (push-mark (point))
    (re-search-forward "|")
    (backward-char)
    (skip-chars-backward " ")
    (push-mark (point))
    (set-mark (point))
    (org-table-beginning-of-field 1)))

;;;; dwim

(defun handy-expand-region-dwim (arg)
  "If region is active, call `er/expand-region'.  If not call `er/mark-word'."
  (interactive "p")
  (if (or (region-active-p) (equal last-command this-command))
      (er/expand-region arg)
    (er/mark-word)
    (if (equal arg 4) (exchange-point-and-mark))))

(defun handy-mark-dwim (arg)
  "Mark the url, sexp or sentence at point.

If point is in a url, call `er/mark-url'.  If not mark sexp at point.
If call 2 times consecutively, call `er/mark-sentence'."
  (interactive "p")
  (cond
   ((equal last-command this-command)
    (er/mark-sentence))
   ((handy-point-in-url-p)
    (er/mark-url))
   ((or (handy-point-at-beginning-of-sexp-delimited-by-pairs-p)
        (eq (following-char) ?<))
    (sp-mark-sexp))
   ((eq (preceding-char) ?\")
    (sp-backward-sexp)
    (sp-mark-sexp))
   ((and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
         (looking-back "[[:alnum:]]" 1))
    (backward-char 1)
    (handy-mark-sexp-at-point))
   (t (handy-mark-sexp-at-point)))
  (if (equal arg 4) (exchange-point-and-mark)))

(defun handy-mark-inside-dwim (&optional arg)
  "Mark things inside quotes if point is inside a string.

If not inside string, mark inside table field in `org-mode'.
In other modes, mark things inside pairs.
If call two times consecutively mark inside pairs."
  (interactive)
  (cond ((equal last-command this-command)
         (call-interactively 'handy-mark-inside-pairs))
        ((er--point-inside-string-p)
         (call-interactively 'er/mark-inside-quotes))
        ((and (equal major-mode 'org-mode) (org-at-table-p))
         (handy-mark-inside-field))
        (t (call-interactively 'handy-mark-inside-pairs))))

;;; Miscellaneous

(defun handy-cycle-spacing ()
  "Wrapper on `cycle-spacing' to call it in \"fast\" mode."
  (interactive)
  (cycle-spacing nil nil 'fast))

(defun handy-add-space ()
  "Add space at point without moving."
  (interactive)
  (insert " ")
  (goto-char (- (point) 1)))

;;; Comments

(comment ; plist-get, <, handy-sp-touch
 (plist-get (sp-get-thing) :beg)
 (plist-get (sp-get-thing t) :beg)
 (handy-sp-touch)
 (< 1 3 5) ;; t
 (< 1 3 3) ;; nil
 (global-set-key (kbd "C-<f1>") 'handy-sp-touch)
 ;; (test-1 test-3 test-2)
 ;; (test-d-e-f)
 ;; (test-a-b-c)
 ;; (test-g-h-i)
 )

(comment ; thing-at-point, handy-point-in-url-p
 (with-temp-buffer
   (insert "https://tonyaldon.com and ...")
   (search-backward "tony")
   (handy-point-in-url-p))
 (thing-at-point 'sentence)
 (thing-at-point 'word)
 (thing-at-point 'url)
 )

;;; Footer

(provide 'handy)

#+END_SRC

** emacs-lisp
To write my own ~emacs~ commands, I used the following ~variables~,
~functions~, ~macros~ and ~special forms~.
*** variables
- ~this-command~
- ~last-command~
*** functions
**** from [[https://github.com/magnars/expand-region.el][expand-region]]
- ~er--point-inside-string-p~
**** built-in
- ~region-active-p~
- ~this-command-keys-vector~
- ~make-string~
- ~aref~
- ~cdr~
- ~assoc~
- ~exchange-point-and-mark~
- ~commandp~
- ~functionp~
- ~funcall~
- ~eval~
- ~self-insert-command~
- ~outline-on-heading-p~
- ~error~
- ~bolp~
- ~local-set-key~
- ~cycle-spacing~
- ~skip-chars-backward~
- ~push-mark~
- ~set-mark~
- ~thing-at-point~
- ~string-empty-p~
- ~split-line~
* Step 12 (November 08, 2020 - January 28, 2021)
commit f7a3031f308c1716ebe28cb458d7b08d54cc34de (v3.0.0).

I used emacs 28.50.

I starded setting up and adding some custom commands to ~org-mode~.  I
started binding /mouse/ events.  This is useful when I am focus in
reading code.  I set up my programming environment to only use ~spaces~
and /not/ ~TABS~ except for ~make-mode~.  To be consistent, I replaced, in my
source code, each ~TAB~ by two ~spaces~.  I use ~whitespace-mode~ in
~prog-mode~.  This allow me to catch ~TABS~ when copying code from
another source.  I used a ~transient~ command for some useful commands,
I always forgot the name, and that do not need a first class key
bindings.  I grouped all my custom commands related to linux in the
package ~linux~.  I brought the macro ~comment~ from /clojure/ to /emacs/.  To
shorten the time to produce the videos [[https://www.youtube.com/channel/UCQCrbWOFRmFYqoeou0Qv3Kg][Inside Emacs]], I wrote some
custom commands that are grouped into the repository
[[https://github.com/tonyaldon/inside-emacs-tooling][inside-emacs-tooling]].  Mainly, this handles ~svg~ and ~kdenlive~ files
generation for the videos /Inside Emacs/.  There is also a command to
access the last video being edited.

** org-mode

#+BEGIN_SRC emacs-lisp
;;; Packages
(require 'org)

;;; Global

(setq org-use-speed-commands t)
(setq org-return-follows-link t)
(setq org-export-backends '(ascii beamer html icalendar latex md))
(set-default 'org-link-frame-setup '((file . find-file)))
(add-to-list 'org-file-apps '(directory . emacs))

;;; time
(setq system-time-locale "C")
(setq org-log-done 'time)

;;; tags
(setq org-tags-column -77) ; default value

;;; src and babel

(require 'ob-js)
;; https://emacs.stackexchange.com/questions/55690/org-babel-javascript-error
(setq org-babel-js-function-wrapper
      "console.log(require('util').inspect(function(){\n%s\n}(), { depth: 100 }))")

(setq org-edit-src-content-indentation 0)

(org-babel-do-load-languages
 'org-babel-load-languages '((js . t)
                             (shell . t)
                             (python . t)
                             (dot . t)))

(defun ta-org-confirm-babel-evaluate (lang body)
  (and (not (string= lang "emacs-lisp"))
       (not (string= lang "dot"))))  ; don't ask for ditaa

(setq org-confirm-babel-evaluate 'ta-org-confirm-babel-evaluate)

;;; Tables

(setq org-table-tab-jumps-over-hlines t)

(defun ta-org-table-previous-row ()
  "Go to the previous row (same column) in the current table.
Before doing so, re-align the table if necessary."
  (interactive)
  (unless (org-at-table-hline-p)
    (org-table-maybe-eval-formula)
    (org-table-maybe-recalculate-line))
  (if (and org-table-automatic-realign
           org-table-may-need-update)
      (org-table-align))
  (let ((col (org-table-current-column)))
    (when (and (org-at-table-p)
               (not (= (org-table-current-line) 1)))
      (previous-line)
      (unless (org-at-table-hline-p)
        (org-table-goto-column col)))))

(defun ta-org-meta-return (&optional arg)
  "Insert a new heading or wrap a region in a table.
Calls `org-insert-heading', `org-insert-item' or
`org-table-wrap-region', depending on context.

In table, `org-meta-return' calls `org-table-wrap-region' interactively
but it DOESN'T PASS the prefix arg.  So using `org-meta-return' in table
to run `org-table-wrap-region' does't work as expected.
Below you have a workaround to have full power of `org-table-wrap-region'
when calling `org-meta-return' in tables."
  (interactive "P")
  (org-check-before-invisible-edit 'insert)
  (or (run-hook-with-args-until-success 'org-metareturn-hook)
      (if (org-at-table-p)
          (org-table-wrap-region arg)
        (call-interactively (cond (arg #'org-insert-heading)
                                  ((org-in-item-p) #'org-insert-item)
                                  (t #'org-insert-heading))))))

(defun ta-org-shiftmetadown (&optional _arg)
  "Drag the line at point down.
In a table, insert an empty row below the current line (this part
differs from the original `org-shiftmetadown' command).
On a clock timestamp, update the value of the timestamp like `S-<down>'
but also adjust the previous clocked item in the clock history.
Everywhere else, drag the line at point down."
  (interactive "P")
  (cond
   ((run-hook-with-args-until-success 'org-shiftmetadown-hook))
   ((org-at-table-p) (org-table-insert-row 'below))
   ((org-at-clock-log-p) (let ((org-clock-adjust-closest t))
                           (call-interactively 'org-timestamp-down)))
   (t (call-interactively 'org-drag-line-forward))))

(defun org-self-insert-command (N)
  "Like `self-insert-command', use overwrite-mode for whitespace in tables.
If the cursor is in a table looking at whitespace, the whitespace is
overwritten, and the table is not marked as requiring realignment.

;; Tony Aldon (overwrite the original command `org-self-insert-command'.)
Add `ta-org-table-previous-row' to the commands after which we want
to blank table field if we start typing just after using it as `org-cycle',
`org-return', `org-shifttab', `org-ctrl-c-ctrl-c' commands."
  (interactive "p")
  (org-check-before-invisible-edit 'insert)
  (cond
   ((and org-use-speed-commands
         (let ((kv (this-command-keys-vector)))
           (setq org-speed-command
                 (run-hook-with-args-until-success
                  'org-speed-command-hook
                  (make-string 1 (aref kv (1- (length kv))))))))
    (cond
     ((commandp org-speed-command)
      (setq this-command org-speed-command)
      (call-interactively org-speed-command))
     ((functionp org-speed-command)
      (funcall org-speed-command))
     ((and org-speed-command (listp org-speed-command))
      (eval org-speed-command))
     (t (let (org-use-speed-commands)
          (call-interactively 'org-self-insert-command)))))
   ((and
     (= N 1)
     (not (org-region-active-p))
     (org-at-table-p)
     (progn
       ;; Check if we blank the field, and if that triggers align.
       (and (featurep 'org-table)
            org-table-auto-blank-field
            (memq last-command
                  '(ta-org-table-previous-row
                    org-cycle org-return org-shifttab org-ctrl-c-ctrl-c))
            (if (or (eq (char-after) ?\s) (looking-at "[^|\n]*  |"))
                ;; Got extra space, this field does not determine
                ;; column width.
                (let (org-table-may-need-update) (org-table-blank-field))
              ;; No extra space, this field may determine column
              ;; width.
              (org-table-blank-field)))
       t)
     (looking-at "[^|\n]*  |"))
    ;; There is room for insertion without re-aligning the table.
    (self-insert-command N)
    (org-table-with-shrunk-field
     (save-excursion
       (skip-chars-forward "^|")
       ;; Do not delete last space, which is
       ;; `org-table-separator-space', but the regular space before
       ;; it.
       (delete-region (- (point) 2) (1- (point))))))
   (t
    (setq org-table-may-need-update t)
    (self-insert-command N)
    (org-fix-tags-on-the-fly)
    (when org-self-insert-cluster-for-undo
      (if (not (eq last-command 'org-self-insert-command))
          (setq org-self-insert-command-undo-counter 1)
        (if (>= org-self-insert-command-undo-counter 20)
            (setq org-self-insert-command-undo-counter 1)
          (and (> org-self-insert-command-undo-counter 0)
               buffer-undo-list (listp buffer-undo-list)
               (not (cadr buffer-undo-list)) ; remove nil entry
               (setcdr buffer-undo-list (cddr buffer-undo-list)))
          (setq org-self-insert-command-undo-counter
                (1+ org-self-insert-command-undo-counter))))))))
;;; Hooks

(add-hook 'org-mode-hook 'org-indent-mode)
(add-hook 'text-mode-hook 'turn-on-auto-fill)

;;; Footer

(provide 'setup-org)

#+END_SRC

** Discarded Packages (in the setup)
I no longer use ~linum~.  I replaced it by ~display-line-numbers~.

| packages/modes | links        |
|----------------+--------------|
| ~linum~          | built-in     |
** New Packages (in the setup)
| packages/modes       | links                |
|----------------------+----------------------|
| ~whitespace-mode~      | built-in             |
| ~inside-emacs-tooling~ | [[https://github.com/tonyaldon/inside-emacs-tooling][inside-emacs-tooling]] |
| ~rainbow-mode~         | [[https://elpa.gnu.org/packages/rainbow-mode.html][rainbow-mode]]         |
** New commands (in the setup)
| packages/modes        | links    |
|-----------------------+----------|
| ~repeat~                | built-in |
** Custom commands
*** Git related

#+BEGIN_SRC emacs-lisp
(defun ta-magit-log-other-window ()
  "Show git logs in other windows."
  (interactive)
  (other-window 1)
  (call-interactively 'magit-log-current)
  (other-window 1))
#+END_SRC

*** transient command to remind some useful commands

#+BEGIN_SRC emacs-lisp
;;;; transient key bindings interface

;;;;; transient interface

(declare-function transient-define-prefix "ext:transient")
(declare-function transient-define-suffix "ext:transient")

(defmacro ta-transient-define-suffix (command)
  "Create a command COMMAND--transient that is a transient suffix command
that call interactively COMMAND."
  (let ((func-name (concat (symbol-name command) "--transient")))
    `(transient-define-suffix ,(intern func-name) ()
       (interactive)
       (call-interactively (quote ,command)))))

;;;;; describe

(declare-function yas-describe-tables "ext:yasnippet")
(declare-function yas-new-snippet "ext:yasnippet")

(ta-transient-define-suffix describe-key)
(ta-transient-define-suffix describe-keymap)
(ta-transient-define-suffix describe-function)
(ta-transient-define-suffix describe-variable)
(ta-transient-define-suffix describe-mode)

;;;;; linux

(require 'linux)

(ta-transient-define-suffix linux-switch-keyboard-layout)
(ta-transient-define-suffix linux-toggle-laptop-output)
(ta-transient-define-suffix linux-toggle-i3bar)
(ta-transient-define-suffix linux-toggle-dpi)
(ta-transient-define-suffix linux-toggle-git-commit-msg)

;;;;; miscellaneous

(ta-transient-define-suffix yas-describe-tables)
(ta-transient-define-suffix yas-new-snippet)
(ta-transient-define-suffix yas-visit-snippet-file)

(ta-transient-define-suffix apropos)
(ta-transient-define-suffix info)
(ta-transient-define-suffix ta-mini-frame-ignore-commands)
(ta-transient-define-suffix image-toggle-display)

;;;;; ta-remind-me

(transient-define-prefix ta-remind-me ()
  "Show menu buffer for miscellaneous commands I often need but do not remember."
  [["describe"
    ("dk" "describe-key" describe-key--transient)
    ("dp" "describe-keymap" describe-keymap--transient)
    ("df" "describe-function" describe-function--transient)
    ("dv" "describe-variable" describe-variable--transient)
    ("dm" "describe-mode" describe-mode--transient)]
   ["linux"
    ("lk" "linux-switch-keyboard-layout" linux-switch-keyboard-layout--transient)
    ("ll" "linux-toggle-laptop-output" linux-toggle-laptop-output--transient)
    ("li" "linux-toggle-i3bar" linux-toggle-i3bar--transient)
    ("ld" "linux-toggle-dpi" linux-toggle-dpi--transient)
    ("lg" "linux-toggle-git-commit-msg" linux-toggle-git-commit-msg--transient)]
   ["yasnippet"
    ("sd" "yas-describe-tables" yas-describe-tables--transient)
    ("sn" "yas-new-snippet" yas-new-snippet--transient)
    ("sf" "yas-visit-snippet-file" yas-visit-snippet-file--transient)]
   ["misc"
    ("a" "apropos" apropos--transient)
    ("i" "info" info--transient)
    ("m" "mini-frame" ta-mini-frame-ignore-commands--transient)
    ("t" "image-toggle-display" image-toggle-display--transient)]])

(global-set-key (kbd "C-M-i") 'ta-remind-me)

#+END_SRC

** Using the mouse
*** to describe things

#+BEGIN_SRC emacs-lisp
(defun ta-mouse-describe-thing-at-point ()
  "Call `ta-describe-thing-at-point' at cursor position."
  (interactive)
  (call-interactively 'mouse-set-point)
  (call-interactively 'ta-describe-thing-at-point))
#+END_SRC

*** with iedit-mode

#+BEGIN_SRC emacs-lisp
(defun ta-mouse-iedit-mode ()
  "Toggle `iedit-mode' on mouse click."
  (interactive)
  (call-interactively 'mouse-set-point)
  (call-interactively 'iedit-mode))

(defun ta-advice-mouse-set-point-iedit-mode (&rest r)
  "Turn off `iedit-mode' if already on.

Intended to be use as advice before of `mouse-set-point'."
  (when iedit-mode (call-interactively 'iedit-mode)))

(advice-add 'mouse-set-point :before 'ta-advice-mouse-set-point-iedit-mode)
#+END_SRC

*** key bindings

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<mouse-3>") 'ta-mouse-iedit-mode)
(global-set-key (kbd "<C-down-mouse-1>") 'mc/add-cursor-on-click)
(global-set-key (kbd "<C-down-mouse-3>") 'ta-mouse-describe-thing-at-point)
#+END_SRC

** Custom packages
*** comment.el

#+BEGIN_SRC emacs-lisp
;;; About

;; I find the "comment" macro in the clojure language really convenient.
;; See https://betweentwoparens.com/rich-comment-blocks#rich-comment.
;;
;; Now, I have it in emacs.
;;
;; You can use it to wrap code:
;; - you don't want emacs evaluates,
;; - but you want to keep in your code.
;;
;; The 4 sexps inside `comment' macro below are ignored:
;;
;; (comment
;;  (newline)
;;  1
;;  "uie"
;;  (kill-line -1))
;;
;; It is a way to comment sexps ready to be evaluated related to your code,
;; which is really handy to explore and understand the code itself.
;;
;; One of the advantage of the `comment' macro compared to ';' to comment
;; the code is that you have syntax highlighting.

;;; Code

(defmacro comment (&rest body)
  "Ignores body and yield nil.

It's a copy of the \"comment\" macro in the clojure language.
See https://betweentwoparens.com/rich-comment-blocks#rich-comment."
  nil)

;;; Comments

(comment
 (newline)
 1
 "uie"
 (kill-line -1))

;;; Footer

(provide 'comment)

#+END_SRC
*** linux.el

#+BEGIN_SRC emacs-lisp
;;; About
;; In this file, we define commands that modify some behaviour of
;; linux OS where emacs lives in, like (i3, xrandr, dpi rendering...)

;;; i3

;;;; Toggle laptop output

(setq linux-i3-config-file "~/work/settings/i3/.config/i3/config")

(defun linux--laptop-output-config-position ()
  "Return buffer position of the config line responsible for the laptop output visibility.

Return nil, if no laptop output visibility configuration line found."
  (save-excursion
    (beginning-of-buffer)
    (when (search-forward "laptop monitor" nil t)
      (next-line)
      (beginning-of-line)
      (point))))

(defun linux-toggle-laptop-output ()
  "Toggle on/off the laptop output visibility.

This is done via the i3 configuration file `linux-i3-config-file'.
Note that you have to restart your linux session to see the changes.

This is useful when using only my laptop to make Zoom calls,
thought I've no external webcam."
  (interactive)
  (let (output)
    (with-temp-buffer
      (insert-file-contents linux-i3-config-file)
      (when-let ((laptop-config (linux--laptop-output-config-position)))
        (goto-char laptop-config)
        (if (looking-at "# ")
            (progn (delete-char 2)
                   (setq output "off"))
          (insert "# ")
          (setq output "on")))
      (write-region (point-min) (point-max) linux-i3-config-file))
    (if output (message (concat "Laptop output turned: " output))
      (message "No 'laptop monitor' config line found in `linux-i3-config-file'"))))

;;;; Toggle i3bar visibility

(defun linux--i3bar-is-hidden-p ()
  "Return t if i3bar is hidden."
  (s-blank-p (shell-command-to-string "i3-msg -t get_tree | grep '\"class\":\"i3bar\"'")))

(defun linux-toggle-i3bar ()
  "Toggle visibility of i3bar."
  (interactive)
  (let ((inhibit-message t))
    (if (linux--i3bar-is-hidden-p)
        (shell-command "i3-msg bar mode dock")
      (shell-command "i3-msg bar mode invisible"))))

;; COMMENTS
;; (s-blank-p "")
;; (shell-command-to-string "ls")
;; (shell-command-to-string "i3-msg -t get_tree | grep '\"class\":\"i3bar\"'")
;; (shell-command "i3-msg bar mode invisible")
;; (shell-command "i3-msg bar mode dock")

;;; Monitor DPI

(setq linux-xresources "~/work/settings/uconfig/.Xresources")

(defun linux-toggle-dpi ()
  "Toggle the DPI in the file ~/.Xresources between 216 and 96.

96 is the default DPI setting.
216 is the DPI setting for screencasting. Setting it that big has
for consequence to zoom in everything in the screen.

Note that you have to restart your linux session to see the changes."
  (interactive)
  (let (dpi)
    (with-temp-buffer
      (insert-file-contents linux-xresources)
      (beginning-of-buffer)
      (cond
       ((search-forward "96" nil t)
        (delete-char -2)
        (insert "216")
        (setq dpi "216"))
       ((search-forward "216" nil t)
        (delete-char -3)
        (insert "96")
        (setq dpi "96"))
       (t nil))
      (write-region (point-min) (point-max) linux-xresources))
    (if dpi (message (concat "Xft.dpi: " dpi))
      (message "Neither 96 nor 216 is the DPI in ~/.Xresources file"))))

;;; Keyboard layout

(defun linux-switch-keyboard-layout ()
  "Switch keyboard layout variant between\"takbl\" and \"takbl fr\"."
  (interactive)
  (let ((variant (shell-command-to-string "setxkbmap -query | grep variant | awk -F' '  '{ print $2 }'")))
    (if (string= variant "fr\n")
        (progn
          (shell-command-to-string "setxkbmap -layout takbl")
          (message "takbl"))
      (shell-command-to-string "setxkbmap -layout takbl -variant fr")
      (message "takbl - fr"))))

;;; Git (format commit message)

(defun linux-toggle-git-commit-msg ()
  "Set the git hook \"prepare-commit-msg\".

If it already exist (ie: not ends with \".sample\") bypass it. It is mandatory when
you rebase/rewrite your git history.
If it doesn't exist, create it with the following content:
\"
#!/bin/bash
COMMIT_MSG_FILEPATH=$1
HINT=`cat $COMMIT_MSG_FILEPATH`

echo \"Subject line\" > $COMMIT_MSG_FILEPATH
echo \"\" >> $COMMIT_MSG_FILEPATH
for cached_file in `git diff --cached --name-only | sed 's/ /\n/g'`;do
    echo \"* $cached_file:\" >> $COMMIT_MSG_FILEPATH;
done
echo \"$HINT\" >> $COMMIT_MSG_FILEPATH
\""
  (interactive)
  (when-let* ((hooks (concat (cdr (project-current)) ".git/hooks/"))
              (prepare-commit-msg (concat hooks "prepare-commit-msg")))
    (if (file-exists-p prepare-commit-msg)
        (progn (delete-file prepare-commit-msg)
               (message "\"%s\" has been removed" (file-name-nondirectory prepare-commit-msg)))
      (with-temp-file prepare-commit-msg
        (insert
         "#!/bin/bash
COMMIT_MSG_FILEPATH=$1
HINT=`cat $COMMIT_MSG_FILEPATH`

echo \"Subject line\" > $COMMIT_MSG_FILEPATH
echo \"\" >> $COMMIT_MSG_FILEPATH
for cached_file in `git diff --cached --name-only | sed 's/ /\\n/g'`;do
    echo \"* $cached_file:\" >> $COMMIT_MSG_FILEPATH;
done
echo \"$HINT\" >> $COMMIT_MSG_FILEPATH"))
      (shell-command (concat "chmod +x " prepare-commit-msg))
      (message "\"%s\" has been created" (file-name-nondirectory prepare-commit-msg)))))

;; COMMENTS
;; (shell-command "ls")
;; (shell-command-to-string "ls")
;; (global-set-key (kbd "C-<f1>") 'linux-toggle-git-commit-msg)

;;; Footer
(provide 'linux)

#+END_SRC

** emacs-lisp
To write my own ~emacs~ commands, I started using the following
~variables~, ~functions~, ~macros~ and ~special forms~.
*** variables
- ~inhibit-message~
*** macros
- ~defmacro~
- ~if-let~
- ~when-let*~
- ~with-temp-buffer~
- ~with-temp-file~
*** functions
**** from [[https://github.com/magnars/dash.el][dash]]
- ~--annotate~
- ~--each-indexed~
- ~--map-indexed~
- ~--reduce-from~
- ~-elem-index~
- ~-last-item~
**** from [[https://github.com/rejeep/f.el][f.el]]
- ~f-exists?~
- ~f-full~
- ~f-join~
- ~f-mkdir~
- ~f-write~
**** from [[https://github.com/magit/magit][magit]]
- ~magit-log-current~
**** from [[https://github.com/magnars/s.el][s]]
- ~s-blank-p~
- ~s-contains-p~
- ~s-downcase~
- ~s-lines~
- ~s-replace~
**** built-in (dom)
- ~dom-append-child~
- ~dom-node~
- ~dom-print~
**** built-in (svg)
- ~svg-create~
- ~svg-print~
- ~svg-text~
**** built-in
- ~1+~
- ~add-to-list~
- ~buffer-substring-no-properties~
- ~delete-file~
- ~file-exists-p~
- ~insert-file-contents~
- ~insert-file-contents~
- ~int-to-string~
- ~listify-key-sequence~
- ~list~
- ~mouse-set-point~
- ~nth~
- ~number-sequence~
- ~reverse~
- ~run-hook-with-args-until-success~
- ~shell-command-to-string~
- ~shell-command~
- ~shell-command~
- ~write-region~
- ~write-region~
*** org-mode
**** variables
- ~org-clock-adjust-closest~
**** functions
- ~org-at-clock-log-p~
- ~org-at-table-hline-p~
- ~org-at-table-p~
- ~org-check-before-invisible-edit~
- ~org-drag-line-forward~
- ~org-shiftmetadown-hook~
- ~org-show-all~
- ~org-table-align~
- ~org-table-current-column~
- ~org-table-current-line~
- ~org-table-goto-column~
- ~org-table-insert-row~
- ~org-table-maybe-eval-formula~
- ~org-table-maybe-recalculate-line~
- ~org-table-wrap-region~
- ~org-timestamp-down~
* Step 11 (July 31, 2020 - November 07, 2020)
commit 1c0996c7011b08f5e9a0e89f31832c58c6c49077 (v2.0.0)

I used emacs 28.50.

I made a huge reshaping of my setup.  I tried to separate concern
between /features/, /settings/ and /key bindings/.  Features are grouped
into packages with a name (they are no longer simple tweaks at the
margin).  We welcome these new packages in the setup:
- ~ace-hacks.el~
- ~framer.el~
- ~i3.el~
- ~insight.el~
- ~outline-speed-commands.el~
~- ~quick-access
~- ~refactor.el~
- ~screencast.el~
- ~sidebar.el~

I rather use ~isearch-forward~ and ~isearch-backward~ than ~swiper~.  I
rather use [[https://github.com/bling/fzf.el][fzf.el]] to find file than any other ~find-file-...~ commands.
I forked [[https://github.com/bling/fzf.el][fzf.el]] and I had it some features that it can works with my
new ~ace-hacks~ package.  I really like the interface that is really
fast and doesn't use any completion framework since the completion is
done in a ~term-mode~ buffer.  To find /patterns recursively/ in
/directories/ I used both ~counsel-rg~ (from [[https://github.com/abo-abo/swiper][ivy]]) and ~rg-dwim~ (from
[[https://github.com/dajva/rg.el][rg.el]]).  I /jumped to definition/ with [[https://github.com/jacktasia/dumb-jump][dumb-jump]] packages.  I discovered
*speed keys* in ~org-mode~.  It's amazing.  Single keystrokes can execute
custom commands in an Org file when point is on a headline.  Speed
Keys can speed navigation or execute custom commands.  I bring /speed
keys/ to any mode using ~outline-mode~ writing the package
~outline-speed-commands~.  This gives super power when navigating within
a single file.  I started using [[https://github.com/muffinmad/emacs-mini-frame][mini-frame]].  I started using [[https://github.com/clojure-emacs/cider][cider]] to
work with ~clojure~ code.  I used ~aggressive-indent~.  I started setting
up ~ibuffer~.

** Huge reshaping
*** New shape

#+BEGIN_SRC text
.
|-- settings/
    |-- key-bindings       # Key bindings (main entry: kb.el)
    |-- packages           # Code pieces that are no longer consider as
    |   |                  # tweaks but as features on their own right
    |   |-- ace-hacks.el
    |   |-- framer.el
    |   |-- i3.el
    |   |-- insight.el
    |   |-- outline-speed-commands.el
    |   |-- quick-access.el
    |   |-- refactor.el
    |   |-- screencast.el
    |   |-- sidebar.el
    |-- settings           # Settings of external packages and mine
    |                      # (main entry: setup-init.el)
    |-- utils              # Functionality that is not use on daily bases
#+END_SRC

*** Package descriptions
- ace-hacks.el :: Commands that use ace-window to place buffers in the
  frame in different context (dired-mode, ibuffer-mode,
  ivy-minibuffer).
- framer.el :: Kind of winner-undo but that is not attached to the
  frame you are in and where you have to grab the window configuration
  'manually'.
- i3.el :: Major mode to write i3 conf file.
- insight.el :: Enhances your browsing experience and the insight you
  have of your displayed buffers. insight-mode mode binds one
  character keys to various scrolling commands, zooming commands,
  narrowing commands and outline-minor-mode navigating commands.
- outline-speed-commands.el :: Minor mode that bring kind of
  org-speed-commands that respect outline-regexp.
- quick-access.el :: Mecanism that uses ivy to access to the files and
  directories I use the most.
- refactor.el :: Toggle in write or read mode for several modes
  (grep-mode, dired-mode,...).
- screencast.el :: Minor global mode that sets up emacs to record
  screencast.
- sidebar.el :: Sidebar with both dired and ibuffer on the left side.

*** Custom packages
**** ace-hacks.el
Commands that use ~ace-window~ to *place* /buffers/ in the /frame/ in
different context (~dired-mode~, ~ibuffer-mode~, ~ivy-minibuffer~).

#+BEGIN_SRC emacs-lisp
;;; Packages

(require 'ace-window)
(require 'dired)
(require 'ivy)
(require 'ibuffer)

;;; Utility functions

(defun ace-hacks-visite (buffer-or-file &optional direction)
  "Visite FILE-OR-BUFFER in DIRECTION in the `selected-window'

after having split it.
DIRECTION must be one of this keywords: :left, :right, :up, :down.
If DIRECTION is nil or omitted, visite FILE-OR-BUFFER in the `selected-window'."
  (unless (one-window-p) (call-interactively 'ace-window))
  (cond
   ((eq direction :left)
    (split-window-right))
   ((eq direction :right)
    (split-window-right)
    (windmove-right))
   ((eq direction :up)
    (split-window-below)
    (recenter))
   ((eq direction :down)
    (split-window-below)
    (recenter)
    (windmove-down))
   (t nil))
  (if (bufferp buffer-or-file)
      (switch-to-buffer buffer-or-file)
    (find-file buffer-or-file)))

;;; Dired

(defun ace-hacks-dired-find-file ()
  "Open file at point in window selected with `ace-window'."
  (interactive)
  (when-let ((file-at-point (dired-file-name-at-point)))
    (ace-hacks-visite (expand-file-name file-at-point) nil)))

(defun ace-hacks-dired-find-file-split-left ()
  "Open file at point on the left part of the split window
selected with `ace-window'."
  (interactive)
  (when-let ((file-at-point (dired-file-name-at-point)))
    (ace-hacks-visite (expand-file-name file-at-point) :left)))

(defun ace-hacks-dired-find-file-split-right ()
  "Open file at point on the right part of the split window
selected with `ace-window'."
  (interactive)
  (when-let ((file-at-point (dired-file-name-at-point)))
    (ace-hacks-visite (expand-file-name file-at-point) :right)))

(defun ace-hacks-dired-find-file-split-up ()
  "Open file at point on the up part of the split window
selected with `ace-window'."
  (interactive)
  (when-let ((file-at-point (dired-file-name-at-point)))
    (ace-hacks-visite (expand-file-name file-at-point) :up)))

(defun ace-hacks-dired-find-file-split-down ()
  "Open file at point on the down part of the split window
selected with `ace-window'."
  (interactive)
  (when-let ((file-at-point (dired-file-name-at-point)))
    (ace-hacks-visite (expand-file-name file-at-point) :down)))

;;; Ibuffer

(defun ace-hacks-ibuffer-visit-buffer ()
  "Visit buffer at point in window selected with `ace-window'."
  (interactive)
  (when-let ((buffer-at-point (ibuffer-current-buffer t)))
    (ace-hacks-visite buffer-at-point nil)))

(defun ace-hacks-ibuffer-visit-buffer-split-left ()
  "Visit buffer at point on the left part of the split window
selected with `ace-window'."
  (interactive)
  (when-let ((buffer-at-point (ibuffer-current-buffer t)))
    (ace-hacks-visite buffer-at-point :left)))

(defun ace-hacks-ibuffer-visit-buffer-split-right ()
  "Visit buffer at point on the right part of the split window
selected with `ace-window'."
  (interactive)
  (when-let ((buffer-at-point (ibuffer-current-buffer t)))
    (ace-hacks-visite buffer-at-point :right)))

(defun ace-hacks-ibuffer-visit-buffer-split-up ()
  "Visit buffer at point on the up part of the split window
selected with `ace-window'."
  (interactive)
  (when-let ((buffer-at-point (ibuffer-current-buffer t)))
    (ace-hacks-visite buffer-at-point :up)))

(defun ace-hacks-ibuffer-visit-buffer-split-down ()
  "Visit buffer at point on the down part of the split window
selected with `ace-window'."
  (interactive)
  (when-let ((buffer-at-point (ibuffer-current-buffer t)))
    (ace-hacks-visite buffer-at-point :down)))

;;; Ivy

(defvar ace-hacks-ivy-callers-alist
  '((ivy-switch-buffer . ivy--switch-buffer-action)
    (ivy-switch-buffer-other-window . ivy--switch-buffer-action)
    (counsel-find-file . (lambda (buffer-or-file)
                           (find-file (expand-file-name buffer-or-file ivy--directory)))))
  "Alist of (CALLER . RESOLVER) used with `ivy'.

When `ivy' system completion is called with CALLER and the selected element
is ELT, the function RESOLVER is called with ELT as argument.
For instance, (ivy-switch-buffer . ivy--switch-buffer-action) is valid
association and so '((ivy-switch-buffer . ivy--switch-buffer-action)) is a valid
value for `ace-hacks-ivy-callers-alist'.")

(defun ace-hacks--ivy-visit (buffer-or-file caller)
  "Function to be used within ivy actions."
  (when-let (resolver (alist-get caller ace-hacks-ivy-callers-alist))
    (funcall resolver buffer-or-file)))

(defun ace-hacks--ivy-visit-action (buffer-or-file direction)
  "Visite FILE-OR-BUFFER in DIRECTION in the `selected-window'

after having split it.
DIRECTION must be one of this keywords: :left, :right, :up, :down.
If DIRECTION is nil or omitted, visite FILE-OR-BUFFER in the `selected-window'."
  (let ((caller (ivy-state-caller ivy-last)))
    (if (not (alist-get caller ace-hacks-ivy-callers-alist))
        (message "caller (%s) not listed in ace-hacks-ivy-callers-alist" caller)
      (unless (one-window-p) (call-interactively 'ace-window))
      (cond
       ((eq direction :left)
        (split-window-right))
       ((eq direction :right)
        (split-window-right)
        (windmove-right))
       ((eq direction :up)
        (split-window-below)
        (recenter))
       ((eq direction :down)
        (split-window-below)
        (recenter)
        (windmove-down))
       (t nil))
      (ace-hacks--ivy-visit buffer-or-file caller))))

(defun ace-hacks-ivy-visit ()
  "Visit `ivy' selection in window selected with `ace-window'.
This command must be bind in `ivy-minibuffer-map'."
  (interactive)
  (ivy-set-action (lambda (selection)
                    (ace-hacks--ivy-visit-action selection t)))
  (ivy-done))

(defun ace-hacks-ivy-visit-split-left ()
  "Visit `ivy' selection on the left part of the split window
selected with `ace-window'.
This command must be bind in `ivy-minibuffer-map'."
  (interactive)
  (ivy-set-action (lambda (selection)
                    (ace-hacks--ivy-visit-action selection :left)))
  (ivy-done))

(defun ace-hacks-ivy-visit-split-right ()
  "Visit `ivy' selection on the right part of the split window
selected with `ace-window'.
This command must be bind in `ivy-minibuffer-map'."
  (interactive)
  (ivy-set-action (lambda (selection)
                    (ace-hacks--ivy-visit-action selection :right)))
  (ivy-done))

(defun ace-hacks-ivy-visit-split-up ()
  "Visit `ivy' selection on the up part of the split window
selected with `ace-window'.
This command must be bind in `ivy-minibuffer-map'."
  (interactive)
  (ivy-set-action (lambda (selection)
                    (ace-hacks--ivy-visit-action selection :up)))
  (ivy-done))

(defun ace-hacks-ivy-visit-split-down ()
  "Visit `ivy' selection on the down part of the split window
selected with `ace-window'.
This command must be bind in `ivy-minibuffer-map'."
  (interactive)
  (ivy-set-action (lambda (selection)
                    (ace-hacks--ivy-visit-action selection :down)))
  (ivy-done))

;;; Footer

(provide 'ace-hacks)
#+END_SRC

**** framer.el
Kind of ~winner-undo~ but that is /not attached/ to the /frame/ you are in
and where you have to grab the window configuration /manually/.

#+BEGIN_SRC emacs-lisp
(require 'ring)

(defvar framer-ring-size 10)
(defvar framer-ring nil)
(defvar framer-undo-counter nil)
(defvar framer-redo-frame nil)

(defun framer-set-ring ()
  "Initialize `framer-ring' to an empty ring if not define yet."
  (unless framer-ring
    (setq framer-ring (make-ring framer-ring-size))))

(defun framer-flush ()
  "Flush `framer-ring'."
  (interactive)
  (setq framer-ring (make-ring framer-ring-size)))

(defun framer-push ()
  "Push the window's state into `framer-ring'."
  (interactive)
  (framer-set-ring)
  (ring-insert framer-ring (window-state-get)))

(defun framer-undo ()
  "Cycle through `framer-ring'."
  (interactive)
  (unless (eq last-command 'framer-undo)
    (setq framer-redo-frame (window-state-get))
    (setq framer-undo-counter 0)
    (framer-set-ring))
  (unless (ring-empty-p framer-ring)
    (window-state-put (ring-ref framer-ring framer-undo-counter))
    (cl-incf framer-undo-counter)))

(defun framer-redo ()
  "Go back to the last window's state before start to

cycling in `framer-ring' with `framer-undo'."
  (interactive)
  (if (eq last-command 'framer-undo)
      (window-state-put framer-redo-frame)))


(provide 'framer)
#+END_SRC

**** i3.el
Major mode to write ~i3~ conf file.

#+BEGIN_SRC emacs-lisp
(defvar i3-font-lock-keywords
  '(;; for ~/.config/i3/config
    ("bindsym" . font-lock-keyword-face)
    ("^set" . font-lock-keyword-face)
    ("^mode" . font-lock-keyword-face)
    ("^exec" . font-lock-keyword-face)
    ("^workspace" . font-lock-keyword-face)
    ("^bar" . font-lock-builtin-face)
    ("^assign" . font-lock-keyword-face)
    ("^for_window" . font-lock-keyword-face)
    ("\\(colors\\) [{]+" 1 font-lock-builtin-face t)
    ("^font" . font-lock-builtin-face)
    ("^floating_modifier" . font-lock-builtin-face)
    ("bindsym \\([^ ]*\\)" 1 font-lock-function-name-face t)
    ;; for ~/.i3status.conf file
    ("^[ \t]*\\(.+?\\)\\(?:\\[\\(.*?\\)\\]\\)?[ \t]*[^+]=" 1 font-lock-variable-name-face t)
    ("\\(^order\\) \\(?:[+][=]+\\)" 1 font-lock-keyword-face t)
    ("\\(general\\) [{]+" 1 font-lock-builtin-face t)
    ("\\(run_watch VPN\\) [{]+" 1 font-lock-builtin-face t)
    ("\\(run_watch DHCP\\) [{]+" 1 font-lock-builtin-face t)
    ("\\(wireless _first_\\) [{]+" 1 font-lock-builtin-face t)
    ("\\(disk\\) .* [{]+" 1 font-lock-builtin-face t)
    ("\\(load\\) [{]+" 1 font-lock-builtin-face t)
    ("\\(cpu_usage\\) [{]+" 1 font-lock-builtin-face t)
    ("\\(battery 0\\) [{]+" 1 font-lock-builtin-face t)
    ("\\(tztime local\\) [{]+" 1 font-lock-builtin-face t)
    )
  "Font lock keywords to use in i3-mode.

These keywords are used in the i3 configuration file (~/.config/i3/config)
and i3status configuration file (~/.i3status.conf).")


(define-derived-mode i3-mode sh-mode "i3-mode"
  "Major mode for i3 configuration files."
  (font-lock-add-keywords nil i3-font-lock-keywords))


(provide 'i3)
#+END_SRC

**** insight.el
Enhances your /browsing/ experience and the /insight/ you have of your
displayed buffers.  ~insight-mode~ mode /binds/ *one character keys* to
various /scrolling/ commands, /zooming/ commands, /narrowing/ commands and
outline-minor-mode /navigating/ commands.

#+BEGIN_SRC emacs-lisp
;;; insight.el --- Minor mode to browse buffers -*- lexical-binding: t -*-

;; Copyright (C) 2020  Tony aldon

;; Author: Tony Aldon
;; Maintainer: Tony Aldon <tony.aldon.adm@gmail.com>
;; URL: ???
;; Version: 0.1.0
;; Keywords: scroll, zoom, narrow, outline
;; Package-Requires: ???

;;; Commentary:
;;
;; Insight enhances your browsing experience and the insight you have of
;; your displayed buffers. `insight-mode' mode binds one character keys
;; to various scrolling commands, zooming commands, narrowing commands and
;; `outline-minor-mode' navigating commands.

;; Bind globaly `insight-mode' to any keys that is convenient for your
;; usage, e.g:

;; (global-set-key (kbd "M-i") 'insight-mode)

;; Enable it anytime you want to scroll, zoom, narrow or navigate your code.
;; You can disable it by pressing the 'q' key .

;; If the one character keys don't fit your workflow, change the bindings in
;; `insight-mode-map'.

;; With `insight-ace-window' command, you can interactively choose the displayed
;; buffer to be scroll by commands like `scroll-other-window' and
;; `scroll-other-window-down'. To work well we advice `scroll-other-window'
;; and `scroll-other-window-down' commmands. To do so, add this line to your
;; emacs configuration file:

;; (insight-set-window-advices)

;; At any moment you can revoke it by running: M-x insight-unset-advices.

;; To set up `insight-mode' to change the cursor color to `insight-cursor-color'
;; when `insight-mode' is turned on, add this line to your emacs configuration file:

;; (insight-use-cursor-color)

;; You can set the cursor color in `insight-mode', for instance to blue (#0000ff),
;; by setting the variable `insight-cursor-color' like this:

;; (setq insight-cursor-color "#0000ff")

;; So a standard configuration with `insight-cursor-color' blue is:

;; (setq insight-cursor-color "#0000ff")
;; (insight-use-cursor-color)
;; (insight-set-window-advices)

;;; Change Log: ???

;;; Code:

;;; Cursor

(defvar insight-cursor-color "#fd971f"
  "Color of the cursor when `insight-mode' is turned on.")

(setq insight-use-cursor-color nil)
(setq insight-cursor-color-default nil)

(defun insight-check-cursor-color ()
  "Check if the cursor color is well set according to `insight-mode'."
  (interactive)
  (let ((cursor-color (face-attribute 'cursor :background)))
    (if insight-mode
        (unless (string= cursor-color insight-cursor-color)
          (set-cursor-color insight-cursor-color))
      (when (string= cursor-color insight-cursor-color)
        (set-cursor-color insight-cursor-color-default)))))

(defun insight-use-cursor-color ()
  "Set up `insight-mode' to change the cursor color to `insight-cursor-color'
when `insight-mode' is turned on."
  (interactive)
  (if insight-use-cursor-color
      (progn
        (setq insight-use-cursor-color nil)
        (setq insight-cursor-color-default nil)
        (remove-hook 'post-command-hook 'insight-check-cursor-color))
    (setq insight-cursor-color-default (face-attribute 'cursor :background))
    (setq insight-use-cursor-color t)
    (add-hook 'post-command-hook 'insight-check-cursor-color)))

(defun insight-switch-cursor-color (insight-mode)
  "Modify the color of the cursor when `insight-mode' is turned on

and `insight-use-cursor-color' is 't'."
  (when insight-use-cursor-color
    (if insight-mode
        (progn
          (setq-local insight-cursor-color-default-local (face-attribute 'cursor :background))
          (set-cursor-color insight-cursor-color))
      (set-cursor-color insight-cursor-color-default-local))))

;;; Tweaked scroll commands

(defun insight-scroll-down-line ()
  "Scroll down of one line"
  (interactive)
  (scroll-up-line -1))

(defun insight-scroll-up-line ()
  "Scroll up of one line"
  (interactive)
  (scroll-up-line))

(defun insight-scroll-other-window-up-line ()
  "Scroll up of one line in other window."
  (interactive)
  (scroll-other-window 1))

(defun insight-scroll-other-window-down-line ()
  "Scroll up of one line in other window."
  (interactive)
  (scroll-other-window-down 1))

(defun insight--half-window-height ()
  "Compute half window height."
  (/ (window-body-height) 2))

(defun insight-scroll-down-half-window ()
  "Scroll down of half window height."
  (interactive)
  (scroll-down (insight--half-window-height)))

(defun insight-scroll-up-half-window ()
  "Scroll up of half window height."
  (interactive)
  (scroll-up (insight--half-window-height)))

(defun insight-scroll-other-window-down-half-window ()
  "Scroll other window down of half window height."
  (interactive)
  (scroll-other-window-down (insight--half-window-height)))

(defun insight-scroll-other-window-up-half-window ()
  "Scroll other window up of half window of half window height."
  (interactive)
  (scroll-other-window (insight--half-window-height)))

;;; Scroll other window with `ace-window'

(declare-function ace-window "ext:ace-window")

(defun insight-ace-window ()
  "Interactively choose the displayed buffer to be scroll by commands
like `scroll-other-window' and `scroll-other-window-down'."
  (interactive)
  (let ((initial-window (selected-window)))
    (save-excursion
      (call-interactively 'ace-window)
      (setq other-window-scroll-buffer (current-buffer)))
    (select-window initial-window)))

(defun insight-reset-other-window-scroll-buffer (&optional arg)
  "Reset `other-window-scroll-buffer' to nil if its value is not
a buffer being displayed.

Use this function to advice :before `scroll-other-window' and
`scroll-other-window-down'. This prevents to popup the buffer
`other-window-scroll-buffer' if it was not being displayed."
  (when (and other-window-scroll-buffer
             (or (not (eq 1 (length (get-buffer-window-list other-window-scroll-buffer))))
                 (eq (get-buffer-window other-window-scroll-buffer) (selected-window))))
    (setq other-window-scroll-buffer nil)))

(defun insight-set-window-advices ()
  "Advice `scroll-other-window' and `scroll-other-window-down'.

See `insight-ace-window' and
`insight-reset-other-window-scroll-buffer'."
  (interactive)
  (advice-add 'scroll-other-window :before 'insight-reset-other-window-scroll-buffer)
  (advice-add 'scroll-other-window-down :before 'insight-reset-other-window-scroll-buffer))

(defun insight-unset-window-advices ()
  "Advice `scroll-other-window' and `scroll-other-window-down'.

See `insight-ace-window' and
`insight-reset-other-window-scroll-buffer'."
  (interactive)
  (advice-remove 'scroll-other-window 'insight-reset-other-window-scroll-buffer)
  (advice-remove 'scroll-other-window-down 'insight-reset-other-window-scroll-buffer))

;;; narrow

(declare-function org-toggle-narrow-to-subtree "org")
(declare-function org-narrow-to-element "org")
(declare-function sp-narrow-to-sexp "ext:smartparens")

(defun insight-sp-toggle-narrow (arg)
  "Toggle between `widen' and `sp-narrow-to-sexp'."
  (interactive "P")
  (if (buffer-narrowed-p) (widen)
    (sp-narrow-to-sexp arg)))

;;; keymap

(defvar insight-mode-map
  (let ((map (make-sparse-keymap)))
    ;; outline commands
    (define-key map (kbd "p") 'outline-previous-visible-heading)
    (define-key map (kbd "n") 'outline-next-visible-heading)
    (define-key map (kbd "f") 'outline-forward-same-level)
    (define-key map (kbd "b") 'outline-backward-same-level)
    (define-key map (kbd "i") 'outline-up-heading)
    ;; scrolling commands
    (define-key map (kbd ")") 'scroll-left)
    (define-key map (kbd "(") 'scroll-right)
    (define-key map (kbd "<prior>") 'beginning-of-buffer)
    (define-key map (kbd "<next>") 'end-of-buffer)
    (define-key map (kbd "<backspace>") 'scroll-down)
    (define-key map (kbd "SPC") 'scroll-up)
    (define-key map (kbd "d") 'insight-scroll-down-half-window)
    (define-key map (kbd "s") 'insight-scroll-up-half-window)
    (define-key map (kbd "l") 'insight-scroll-down-line)
    (define-key map (kbd "r") 'insight-scroll-up-line)
    (define-key map (kbd "e") 'insight-scroll-other-window-down-half-window)
    (define-key map (kbd "o") 'insight-scroll-other-window-up-half-window)
    ;; (define-key map (kbd "/") 'insight-scroll-other-window-down-line)
    ;; (define-key map (kbd "`") 'insight-scroll-other-window-up-line)
    (define-key map (kbd "a") 'insight-ace-window)
    ;; narrowing commands
    (define-key map (kbd ".") 'org-toggle-narrow-to-subtree)
    (define-key map (kbd ":") 'org-narrow-to-element)
    (define-key map (kbd ",") 'insight-sp-toggle-narrow)
    (define-key map (kbd ";") 'narrow-to-region)
    (define-key map (kbd "]") 'widen)
    ;; scaling commands
    (define-key map (kbd "+") 'text-scale-increase)
    (define-key map (kbd "-") 'text-scale-decrease)
    (define-key map (kbd "0") 'text-scale-adjust)
    ;; other
    (define-key map (kbd "q") 'insight-mode)
    map)
  "Keymap for `insight-mode'.")


;;; Mode

(define-minor-mode insight-mode
  "Convenient keybindings for zooming, scrolling and narrowing.

Mainly one key binding."
  :lighter " Insight"
  :keymap insight-mode-map
  (insight-switch-cursor-color insight-mode))

(insight-mode -1)

(provide 'insight)
#+END_SRC

**** outline-speed-commands.el
Minor mode that bring kind of ~org-speed-commands~ that respect
~outline-regexp~.

#+BEGIN_SRC emacs-lisp
(require 'outline)

;;; outline-self-insert-command
(defun outline-self-insert-command (N)
  "Like `self-insert-command' but allow speed commands

define in `outline-speed-commands-default' and `outline-speed-commands-user'
when the cursor is at the beginning of an outline headline.

This is a ligth adaptation of `org-self-insert-command'."
  (interactive "p")
  ;; (org-check-before-invisible-edit 'insert)
  (cond
   ((and outline-use-speed-commands
         (let ((kv (this-command-keys-vector)))
           (setq outline-speed-command
                 (run-hook-with-args-until-success
                  'outline-speed-command-hook
                  (make-string 1 (aref kv (1- (length kv))))))))
    (cond
     ((commandp outline-speed-command)
      (setq this-command outline-speed-command)
      (call-interactively outline-speed-command))
     ((functionp outline-speed-command)
      (funcall outline-speed-command))
     ((and outline-speed-command (listp outline-speed-command))
      (eval outline-speed-command))
     (t (let (outline-use-speed-commands)
          (call-interactively 'outline-self-insert-command)))))
   (t
    (setq this-command 'self-insert-command)
    (self-insert-command N))))


;;; Speed keys
(defvar outline-speed-commands-user nil
  "Alist of additional speed commands.
This list will be checked before `outline-speed-commands-default'.
when the cursor is at the beginning of a headline.
The car of each entry is a string with a single letter, which must
be assigned to `self-insert-command' in the global map.
The cdr is either a command to be called interactively, a function
to be called, or a form to be evaluated.
An entry that is just a list with a single string will be interpreted
as a descriptive headline that will be added when listing the speed
commands in the Help buffer using the `?' speed command.")

(defvar outline-speed-command-hook '(outline-speed-command-activate)
  "Hook for activating speed commands at strategic locations.
Hook functions are called in sequence until a valid handler is
found.

Each hook takes a single argument, a user-pressed command key
which is also a `self-insert-command' from the global map.

Within the hook, examine the cursor position and the command key
and return nil or a valid handler as appropriate.  Handler could
be one of an interactive command, a function, or a form.

Turn on `outline-speed-commands-mode' to enable this hook.")

(defconst outline-speed-commands-default
  '(("Outline Navigation")
    ("n" . (outline-speed-move-safe 'outline-next-visible-heading))
    ("p" . (outline-speed-move-safe 'outline-previous-visible-heading))
    ("f" . (outline-speed-move-safe 'outline-forward-same-level))
    ("b" . (outline-speed-move-safe 'outline-backward-same-level))
    ("u" . (outline-speed-move-safe 'outline-up-heading))
    ("Outline Visibility")
    ("i" . outline-show-children)
    ("s" . outline-show-subtree)
    ("d" . outline-hide-subtree)
    ("t" . outline-hide-body)
    ("a" . outline-show-all)
    ("c" . outline-hide-entry)
    ("e" . outline-show-entry)
    ("l" . outline-hide-leaves)
    ("k" . outline-show-branches)
    ("q" . outline-hide-sublevels)
    ("o" . outline-hide-other)
    ("Outline Structure Editing")
    ("@" . outline-mark-subtree)
    ("^". outline-move-subtree-up)
    ("v". outline-move-subtree-down)
    ("<". outline-promote)
    (">". outline-demote)
    ("m". outline-insert-heading)
    "The default Outline speed commands."))

(defun outline-speed-move-safe (cmd)
  "Execute CMD, but make sure that the cursor always ends up in a headline.
If not, return to the original position and throw an error."
  (interactive)
  (let ((pos (point)))
    (call-interactively cmd)
    (unless (and (bolp) (outline-on-heading-p t))
      (goto-char pos)
      (error "Boundary reached while executing %s" cmd))))

(defun outline-speed-command-activate (keys)
  "Hook for activating single-letter speed commands.
`outline-speed-commands-default' specifies a minimal command set.
Use `outline-speed-commands-user' for further customization."
  (when (and (bolp) (looking-at outline-regexp))
    (cdr (assoc keys (append outline-speed-commands-user
                             outline-speed-commands-default)))))

;;; outline-speed-commands-mode
(define-minor-mode outline-speed-commands-mode
  "Toggle outline-speed-commands-mode mode on or off."
  :global nil
  (if outline-speed-commands-mode
      (progn
        (setq-local outline-use-speed-commands t)
        (local-set-key [remap self-insert-command] 'outline-self-insert-command))
    (makunbound 'outline-use-speed-commands)
    (local-set-key [remap self-insert-command] nil)))



(provide 'outline-speed-commands)
#+END_SRC

**** quick-access.el
Mecanism that uses ~ivy~ to /access/ to the files and directories I use
the most.

#+BEGIN_SRC emacs-lisp
(declare-function ivy-read "ext:ivy")

(defvar quick-access-alist ()
  "Association list of quick-access names and its full filename.

The value is an alist with quick-access of the form

 (QUICK-ACCESS-NAME . FILENAME).

QUICK-ACCESS-NAME must be uniq.")

(defun quick-access-all-names ()
  "Return the list of all the quick-access-name define in `quick-access-alist'."
  (-map 'car quick-access-alist))

(defun quick-access-get-filename (quick-access-name)
  "Return the full filename of QUICK-ACCESS-NAME, or nil if none."
  (assoc-default quick-access-name quick-access-alist))

(defun counsel-quick-access ()
  "Open a quick-access file listed in `quick-access-alist'."
  (interactive)
  (ivy-read "Open quick-access: "
            (quick-access-all-names)
            :history 'quick-access-history
            :action (lambda (x)
                      (find-file (quick-access-get-filename x)))
            :caller 'counsel-quick-access))


(provide 'quick-access)
#+END_SRC

**** refactor.el
Toggle in *write* or *read* /mode/ for several modes (~grep-mode~,
~dired-mode~,...).

#+BEGIN_SRC emacs-lisp
;;; Packages
;;; Code

(setq refactor-wgrep-mode-list '(grep-mode ivy-occur-grep-mode rg-mode))

(defun refactor-write-mode ()
  "Toggle to the Writable variant of the current mode.

Call command `dired-toggle-read-only' if `major-mode' is equal
`dired-mode' and call command `wgrep-change-to-wgrep-mode' if
`major-mode' is in `refactor-wgrep-mode-list'."
  (interactive)
  (cond ((string-equal major-mode "dired-mode")
         (call-interactively 'dired-toggle-read-only))
        ((string-equal major-mode "occur-mode")
         (call-interactively 'occur-edit-mode))
        ((memq major-mode refactor-wgrep-mode-list)
         (call-interactively 'wgrep-change-to-wgrep-mode))
        (t (message "In `%s' you can't toggle to `wgrep' like mode"
                    major-mode))))

(defun refactor-abort-changes ()
  "Abort changes and return to the appropiate mode.

Call command `wdired-abort-changes' if `major-mode' is
`wdired-mode' and call command `wgrep-abort-changes' if
`major-mode' is in `refactor-wgrep-mode-list'."
  (interactive)
  (cond ((string-equal major-mode "wdired-mode")
         (call-interactively 'wdired-abort-changes))
        ((memq major-mode refactor-wgrep-mode-list)
         (call-interactively 'wgrep-abort-changes))
        (t nil)))

(defun refactor-exit ()
  "Exit writable mode and return to the appropiate mode.

Call command `wdired-exit' if `major-mode' is
`wdired-mode' and call command `wgrep-exit' if
`major-mode' is in `refactor-wgrep-mode-list'."
  (interactive)
  (cond ((string-equal major-mode "wdired-mode")
         (call-interactively 'wdired-exit))
        ((memq major-mode refactor-wgrep-mode-list)
         (call-interactively 'wgrep-exit))
        (t nil)))

(defun refactor-finish-edit ()
  "Abort changes and return to the appropiate mode.

Call command `wdired-finish-edit' if `major-mode' is
`wdired-mode' and call command `wgrep-finish-edit' if
`major-mode' is in `refactor-wgrep-mode-list'."
  (interactive)
  (cond ((string-equal major-mode "wdired-mode")
         (call-interactively 'wdired-finish-edit))
        ((string-equal major-mode "occur-edit-mode")
         (call-interactively 'occur-cease-edit))
        ((memq major-mode refactor-wgrep-mode-list)
         (call-interactively 'wgrep-finish-edit))
        (t nil)))

;;; Footer

(provide 'refactor)

#+END_SRC

**** screencast.el
Minor global *mode* that *sets up* ~emacs~ to *record* /screencast/.

#+BEGIN_SRC emacs-lisp
;;; Packages
(require 'moody)
(require 'minions)
(require 'keycast)

;;; Mode line

;;;; Format

(defvar screencast-mode-line-format
  '("%e"
    mode-line-front-space
    mode-line-mule-info
    mode-line-client
    mode-line-modified
    mode-line-remote
    mode-line-frame-identification
    moody-mode-line-buffer-identification
    "  "
    minions-mode-line-modes)
  "`mode-line-format' to be used when `screencast-mode' is enable.")

;;;; moody

(defvar screencast-moody-mode-line-height 30
  "`moody-mode-line-height' to be used when `screencast-mode' is enable.")

;;;; minions

(defvar screencast-minions-direct '(insight-mode)
  "`minions-direct' to be used when `screencast-mode' is enable.")

(defvar screencast-minions-mode-line-lighter ""
  "`minions-mode-line-lighter' to be used when `screencast-mode' is enable.")

(defvar screencast-minions-mode-line-delimiters '("" . "")
  "`minions-mode-line-delimiters' to be used when `screencast-mode' is enable.")

(defvar screencast--minions-variables '(minions-direct
                                        minions-mode-line-lighter
                                        minions-mode-line-delimiters)
  "List of `minions' variables that are modified when `screencast-mode' is enable.")

(setq screencast--minions-variables-alist nil)

(defun screencast-set-minions ()
  "Set `minions' variables used by `screencast-mode'."
  (if screencast-mode
      (progn
        (setq screencast--minions-variables-alist
              (--map (cons it (symbol-value it)) screencast--minions-variables))
        (--each screencast--minions-variables
          (let ((item it)
                (item-value (symbol-value
                             (intern (s-concat "screencast-" (symbol-name it))))))
            (set item item-value))))
    (--each screencast--minions-variables
      (let ((item it)
            (item-value (cdr (assoc it screencast--minions-variables-alist))))
        (set item item-value)))))

;;;; keycast

(defvar screencast-keycast-separator-width 2
  "`keycast-separator-width' to be used when `screencast-mode' is enable.")

(defvar screencast-keycast-insert-after 'moody-mode-line-buffer-identification
  "`keycast-insert-after' to be used when `screencast-mode' is enable.")

(defvar screencast-keycast-window-predicate  'moody-window-active-p
  "`keycast-window-predicate' to be used when `screencast-mode' is enable.")

(defvar screencast-keycast-remove-tail-elements nil
  "`keycast-remove-tail-elements' to be used when `screencast-mode' is enable.")

(defvar screencast-keycast-substitute-alist
  '((self-insert-command "." "self-insert-command")
    (org-self-insert-command "." "org-self-insert-command")
    (outline-self-insert-command "." "outline-self-insert-command"))
  "`keycast-substitute-alist' to be used when `screencast-mode' is enable.")

(defvar screencast--keycast-variables '(keycast-separator-width
                                        keycast-insert-after
                                        keycast-window-predicate
                                        keycast-remove-tail-elements
                                        keycast-substitute-alist)
  "List of `keycast' variables that are modified when `screencast-mode' is enable.")

(setq screencast--keycast-variables-alist nil)

(defun screencast-set-keycast ()
  "Set `keycast' variables used by `screencast-mode'."
  (if screencast-mode
      (progn
        (setq screencast--keycast-variables-alist
              (--map (cons it (symbol-value it)) screencast--keycast-variables))
        (--each screencast--keycast-variables
          (let ((item it)
                (item-value (symbol-value
                             (intern (s-concat "screencast-" (symbol-name it))))))
            (set item item-value))))
    (--each screencast--keycast-variables
      (let ((item it)
            (item-value (cdr (assoc it screencast--keycast-variables-alist))))
        (set item item-value)))))

;;; Other

(defvar screencast-display-buffer-alist '()
  "`display-buffer-alist' to be used when `screencast-mode' is enable.")

(defvar screencast-hook-to-remove-alist '()
  "A list of alist (HOOK . FUNCTION) to be removed when `screencast-mode'
is enable.

For instance a valid list is:
  '((window-configuration-change-hook . my-function-1)
    (buffer-list-update-hook . my-function-2))")

;;; Mode

(setq screencast--mode-line-format nil)
(setq screencast--display-buffer-alist nil)
(setq screencast--moody-mode-line-height nil)

(define-minor-mode screencast-mode
  "Toggle Screencast mode on or off.

Set emacs layout to record screencasts.

Turn on `keycast-mode', clean the `mode-line-format', adapt `display-buffer-alist'
to a smaller window frame than usual."
  :global t
  (if screencast-mode
      (progn
        (--each screencast-hook-to-remove-alist (remove-hook (car it) (cdr it)))
        (setq screencast--display-buffer-alist display-buffer-alist)
        (setq display-buffer-alist screencast-display-buffer-alist)
        (setq screencast--moody-mode-line-height moody-mode-line-height)
        (setq moody-mode-line-height screencast-moody-mode-line-height)
        (screencast-set-minions)
        (screencast-set-keycast)
        (setq screencast--mode-line-format mode-line-format)
        (setq-default mode-line-format screencast-mode-line-format)
        (keycast-mode))
    (--each screencast-hook-to-remove-alist (add-hook (car it) (cdr it)))
    (setq display-buffer-alist screencast--display-buffer-alist)
    (setq screencast--display-buffer-alist nil)
    (setq moody-mode-line-height screencast--moody-mode-line-height)
    (setq screencast--moody-mode-line-height nil)
    (screencast-set-minions)
    (screencast-set-keycast)
    (keycast-mode -1) ; should be called before setting mode-line-format
    (setq-default mode-line-format screencast--mode-line-format)
    (setq screencast--mode-line-format nil)))

;;; Footer

(provide 'screencast)
#+END_SRC

**** sidebar.el
/Sidebar/ with both ~dired~ and ~ibuffer~ on the /left side/.

#+BEGIN_SRC emacs-lisp
(require 'dired)
(require 'dired-hacks-utils)
(require 'ibuffer)
(require 'ibuf-ext)

;;; Utility functions

;;;; Windows

(defun sidebar--dired-width (dir)
  "Return the number of characters of the bigger file or directory in

a dired buffer generate with DIR as `dired-directory'."
  (with-current-buffer (dired-noselect dir)
    (-max (--map (length (-last-item (s-split "/" it)))
                 (dired-utils-get-all-files)))))

(defun sidebar--delete-window (window mode)
  "Delete WINDOW if in MODE mode."
  (select-window window)
  (when (equal major-mode mode)
    (delete-window)))

(defun sidebar--delete-dired-windows ()
  "Delete `dired-mode' windows in `window-list'."
  (save-selected-window
    (--each (window-list) (sidebar--delete-window it 'dired-mode))))

(defun sidebar--delete-ibuffer-windows ()
  "Delete `ibuffer-mode' windows in `window-list'."
  (save-selected-window
    (--each (window-list) (sidebar--delete-window it 'ibuffer-mode))))

(defun sidebar-delete-windows ()
  "Delete `ibuffer-mode' and `dired-mode' windows in `window-list'."
  (sidebar--delete-dired-windows)
  (sidebar--delete-ibuffer-windows))

;;;; Side windows

(defun sidebar--side-window-to-window ()
  "Make selected side window the only window in the frame."
  (interactive)
  (let ((buffer (current-buffer))
        wnd-list)
    (delete-window)
    (display-buffer-at-bottom buffer nil)
    (setq wnd-list (window-list))
    (select-window
     (nth (-elem-index buffer (-map 'window-buffer wnd-list))
          wnd-list))
    (delete-other-windows)))

(defun sidebar--side-window-p (window)
  "Return t if WINDOW is a side window."
  (-contains?
   (-map 'car (window-parameters window))
   'window-side))

(defun sidebar-delete-other-windows ()
  "Delete other windows also when the `selected-window' is a side window."
  (interactive)
  (let ((side-window-p (sidebar--side-window-p (selected-window))))
    (if side-window-p (sidebar--side-window-to-window) (delete-other-windows))))

;;;; Frame

(defun sidebar--window-top-left ()
  "Return the window at the top left corner of the current frame."
  (car (--filter (equal '(0 0) (-take 2 (window-edges it)))
                 (window-list))))

(defun sidebar--window-mode (window)
  "Return the `major-mode' of WINDOW."
  (save-selected-window
    (select-window window)
    major-mode))

(defun sidebar-frame-p ()
  "Return true if there is a sidebar display in the frame."
  (interactive)
  (save-selected-window
    (let ((window-top-left (sidebar--window-top-left)))
      (and (equal (sidebar--window-mode window-top-left) 'dired-mode)
           (progn (select-window window-top-left)
                  (ignore-errors (windmove-down))
                  (equal (sidebar--window-mode (selected-window))
                         'ibuffer-mode))))))

;;;; Ibuffer

(defun sidebar-project-name (dir)
  "Return the name of the project the DIR belongs too.

If DIR doesn't belongs to any project, DIR plays the 'role' of project.

See `project-current'."
  (let ((proj dir))
    (when-let (proj-cur (project-current nil dir))
      (setq proj (cdr proj-cur)))
    (nth 1 (nreverse (s-split "/" proj)))))

(defun sidebar-ibuffer-buffer-list (dir)
  "Return buffer list of the project the DIR belongs too.

If DIR doesn't belongs to any project, DIR plays the 'role' of project.
In this case, only buffers with `buffer-file-name' are kept.

See `project-current'."
  (if-let (proj (project-current nil dir))
      (project--buffer-list proj)
    (--filter
     (when-let (bfname (buffer-file-name it))
       (s-contains-p dir bfname))
     (buffer-list))))

(define-ibuffer-filter sidebar-filter
    "Show Ibuffer with all buffers in the `sidebar-ibuffer-buffer-list'."
  (:description nil)
  (with-current-buffer buf
    (-contains-p qualifier buf)))

;;; Sidebar

(setq sidebar-window-state nil)

(defun sidebar ()
  "Pop up a dired buffer on the left of the frame where `dired-directory'

is the `default-directory' of the current buffer.
If the frame contains buffers in `dired-mode', delete them."
  (interactive)
  (cond ((and (sidebar-frame-p)
              (not (eq last-command 'sidebar)))
         (sidebar-delete-windows))
        ((and (eq last-command 'sidebar) sidebar-window-state)
         (progn
           (window-state-put sidebar-window-state)
           (setq sidebar-window-state nil)))
        (t
         (setq sidebar-window-state (window-state-get))
         (sidebar-delete-windows)
         (sidebar-delete-other-windows)
         (let* ((dir default-directory)
                (ibuffer-buffer-name (format "*sidebar-%s*"
                                             (sidebar-project-name dir))))
           (split-window-right (+ (sidebar--dired-width dir) 10)) ; 10 is arbitrary margin
           (ibuffer nil ibuffer-buffer-name
                    (list (cons 'sidebar-filter (sidebar-ibuffer-buffer-list dir))))
           ;; TODO: ibuffer-formats ((modified vc-status-mini " " name))
           (setq-local ibuffer-formats (-concat '((modified " " name)) ibuffer-formats))
           ;; TODO: set ibuffer-groups to (ta-ibuffer-vc-generate-filter-groups-by-vc-root)
           (split-window-below)
           (dired dir)))))

;;; Footer

(provide 'sidebar)

#+END_SRC

** dired-mode

#+BEGIN_SRC emacs-lisp
;;; Packages

(require 'dired)
(require 'dired-hacks-utils)
(require 'dired-subtree)
(require 'dired-narrow)
(require 'dired-hide-dotfiles)
(require 'dired-open)
(require 's)
(require 'dash)
(require 'dired-toggle-sudo)
(require 'dired-collapse)
(require 'wdired)
(require 'dired-x)
(require 'peep-dired)
(require 'dired-rainbow)

;;; Global
(dired-hide-dotfiles-mode)

(setq dired-keep-marker-rename t)
(setq wdired-allow-to-change-permissions nil)
(setq wdired-create-parent-directories t)
(setq dired-narrow-exit-when-one-left t)
(setq dired-clean-up-buffers-too t)
(setq dired-clean-confirm-killing-deleted-buffers t)
(setq dired-dwim-target t)
(setq dired-recursive-copies 'always)
(setq dired-recursive-deletes 'always)
(setq-default dired-listing-switches "-lhAX --group-directories-first")
(setq dired-open-extensions
      '(("pdf" . "evince")
        ("jpg" . "eog")
        ("png" . "eog")))
(setq-default dired-subtree-line-prefix "  ")
(setq-default dired-subtree-use-backgrounds nil)

;; dired-broken-symlink color??

;;; auto-revert-mode

(defun ta-dired-auto-revert ()
  "Set `auto-revert-mode' in `dired-mode' buffers."
  (auto-revert-mode 1)
  (set (make-local-variable 'auto-revert-verbose) nil))

(add-hook 'dired-mode-hook 'ta-dired-auto-revert)

;;; peep-dired

(setq peep-dired-cleanup-on-disable t)
(setq peep-dired-cleanup-eagerly nil)
(setq peep-dired-enable-on-directories nil)
(setq peep-dired-ignored-extensions
      '("mkv" "webm" "mp4" "mp3" "ogg" "iso" "pdf"))
(setq peep-dired-with-register nil)


;;; Subtree

(defun ta-dired-subtree-toggle-all ()
  "Apply `dired-subtree-toggle' to all root directories

in the dired buffer"
  (interactive)
  (setq deactivate-mark t)
  (save-excursion
    (cond
     ((eq last-command 'dired-subtree-toggle-overview)
      (goto-char (point-min))
      (next-line)
      (while (not (eobp))
        (if (dired-utils-is-dir-p) (dired-subtree-toggle))
        (dired-subtree-next-sibling))
      (message "ALL"))
     ((eq last-command 'ta-dired-subtree-toggle-all)
      (goto-char (point-min))
      (next-line)
      (while (not (eobp))
        (if (dired-utils-is-dir-p) (dired-subtree-toggle))
        (dired-subtree-next-sibling))
      (message "ALL"))
     (t
      (goto-char (point-max))
      (previous-line)
      (setq number-line-before-remove (line-number-at-pos))
      (dired-subtree-remove)
      (while (not (bobp))
        (while (not (equal number-line-before-remove (line-number-at-pos)))
          (setq number-line-before-remove (line-number-at-pos))
          (dired-subtree-remove))
        (previous-line))
      (message "OVERVIEW")
      (setq this-command 'dired-subtree-toggle-overview)))))

;;; Header line

(define-minor-mode dired-header-line-mode
  "Show only the last two directories of the path to the current directory
that `dired-mode' is displaying."
  :init-value nil :group 'header-line :group 'dired
  (unless (derived-mode-p 'dired-mode)
    (error "You must be in Dired or a mode derived from it to use this command"))
  (if dired-header-line-mode
      (progn
        (setq path-len (length (s-split "/" (expand-file-name dired-directory))))
        (setq header-line-directories
              (car (last (s-split-up-to "/" (expand-file-name dired-directory)
                                        (- path-len 3)))))
        (setq header-line-format (concat " ↪[" header-line-directories "]")))
    (setq header-line-format  (default-value 'header-line-format))))

(defface ta-dired-header-face nil
  "Face for dired header, first line of buffer in `dired-mode'"
  :group 'dired)

(font-lock-add-keywords
 'dired-mode
 '(("\\(^.*:$\\)" . 'ta-dired-header-face)))

(font-lock-add-keywords
 'wdired-mode
 '(("\\(^.*:$\\)" . 'ta-dired-header-face)))

(add-hook 'dired-before-readin-hook 'dired-header-line-mode)


;;; dired-rainbow
(dired-rainbow-define-chmod executable-unix "#7fffd4" "-.*x.*")
(dired-rainbow-define media "#d4fbcb"
                      ("mp3" "mp4" "MP3" "MP4" "avi" "mpg" "flv" "ogg" "m4a"))
(dired-rainbow-define image "#a4c30d" ("jpg" "jpeg" "png"))
(dired-rainbow-define svg "#8a510f" ("svg"))
(dired-rainbow-define media-editing "#e421e8" ("kdenlive" "aup"))
(dired-rainbow-define plain-text "#ffd500" ("org" "md"))
(dired-rainbow-define emacs-lisp "#00bdd6" ("el"))
(dired-rainbow-define python "#d16500" ("py"))
(dired-rainbow-define js "#bb8415" ("js"))
(dired-rainbow-define shadow (:inherit shadow) "\\.git.*" )

;;; Hooks

(add-hook 'dired-mode-hook (lambda () (dired-hide-details-mode 1)))

;;; Footer

(provide 'setup-dired)

#+END_SRC

** ibuffer

#+BEGIN_SRC emacs-lisp
;;; Packages
(require 'ibuffer)

;;; Global

(defalias 'list-buffers 'ibuffer)
(setq ibuffer-expert t)
(setq ibuffer-use-header-line nil)
(setq ibuffer-never-show-predicates '("^\\*Help" "\\*Backtrace" "\\*Message"
                                      "\\*Warning" "\\*eldoc" "\\*scratch"
                                      "\\*Ibuffer"))

(setq ibuffer-default-sorting-reversep nil)
;;; Format

(setq ibuffer-formats
      '((mark modified vc-status-mini
              " " (name 18 18 :left :elide)
              " " vc-relative-file)
        (mark modified vc-status-mini " "
              (name 24 24 :left :elide)
              " " filename-and-process)))

;;; Filters

(setq ibuffer-show-empty-filter-groups nil)

(setq ibuffer-filter-group-name-face
      '(:inherit font-lock-type-face
        :weight bold
        :underline t))

(setq ibuffer-saved-filter-groups
      '(("Default"
         ("Notes" (or (name . "notes.org")
                      (name . "extra.org")))
         ("Readme" (name . "\\README"))
         ("Youtube" (filename . "youtube"))
         ("Help" (or (name . "\*Help\*")
                     (name . "\*Apropos\*")
                     (name . "\*info\*"))))))

;;; Hooks

(defun ta-ibuffer-mode-hook ()
  "Forme to be runned in by `'ibuffer-mode-hook'."
  (ibuffer-auto-mode 1)
  (ibuffer-switch-to-saved-filter-groups "Default")
  (ibuffer-do-sort-by-alphabetic-directory-first))

(add-hook 'ibuffer-mode-hook 'ta-ibuffer-mode-hook)

;;; Utility functions

(define-ibuffer-sorter alphabetic-directory-first
  "Sort buffers by their names, puting buffer in `dired-mode' first.
Ordering is lexicographic."
  (:description "buffer name and dired-mode")
  (let ((major-mode-a (buffer-local-value 'major-mode (car a)))
        (major-mode-b (buffer-local-value 'major-mode (car b))))
    (cond ((and (equal major-mode-a 'dired-mode) (equal major-mode-b 'dired-mode))
           (string-lessp
            (buffer-name (car a))
            (buffer-name (car b))))
          ((equal major-mode-a 'dired-mode) t)
          (t
           (string-lessp
            (buffer-name (car a))
            (buffer-name (car b)))))))

(defun ta-ibuffer-vc-reduce-group-title (title)
  "Reduce the title string.

\"Git: ~/path-to-vc-root/vc-root/\" ---> \"vc-root\""
  (-second-item (nreverse (s-split "/" title))))

(defun ta-ibuffer-vc-generate-filter-groups-by-vc-root ()
  "Wrapper on `ibuffer-vc-generate-filter-groups-by-vc-root' that reduce

the group title length."
  (let ((filter-groups (ibuffer-vc-generate-filter-groups-by-vc-root)))
    (--map (list (ta-ibuffer-vc-reduce-group-title (car it))
                 (cadr it))
           filter-groups)))

(setq ta-ibuffer-current-filter-groups 0)

(defun ta-ibuffer-switch-filter-groups ()
  "Switch this buffer's filter groups to one off `ibuffer-saved-filter-groups'
or a vc filter groups generated by `ibuffer-vc-generate-filter-groups-by-vc-root'
and `ta-ibuffer-vc-generate-filter-groups-by-vc-root'."
  (interactive)
  (unless (local-variable-p 'ta-ibuffer-current-filter-groups)
    (make-local-variable 'ta-ibuffer-current-filter-groups))
  (let* ((filter-groups-list
          (-concat (list (ta-ibuffer-vc-generate-filter-groups-by-vc-root)
                         (ibuffer-vc-generate-filter-groups-by-vc-root))
                   (-map 'cdr ibuffer-saved-filter-groups)))
         (fgl-length (length filter-groups-list)))
    (setq ta-ibuffer-current-filter-groups
          (if (>= ta-ibuffer-current-filter-groups (1- fgl-length))
              0
            (1+ ta-ibuffer-current-filter-groups)))
    (setq ibuffer-filter-groups (nth ta-ibuffer-current-filter-groups filter-groups-list))
    (ibuffer-update nil t)))

(setq ta-ibuffer--never-show-predicates nil)

(defun ta-ibuffer-toggle-show-buffers-with-predicates ()
  "Toggle between showing or not buffers that match `ibuffer-never-show-predicates'."
  (interactive)
  (unless (local-variable-p 'ta-ibuffer--never-show-predicates)
    (make-local-variable 'ta-ibuffer--never-show-predicates))
  (unless (local-variable-p 'ibuffer-never-show-predicates)
    (make-local-variable 'ibuffer-never-show-predicates))
  (if ta-ibuffer--never-show-predicates
      (progn
        (setq ibuffer-never-show-predicates ta-ibuffer--never-show-predicates)
        (setq ta-ibuffer--never-show-predicates nil))
    (setq ta-ibuffer--never-show-predicates ibuffer-never-show-predicates)
    (setq ibuffer-never-show-predicates nil))
  (ibuffer-update nil t))

#+END_SRC

** Completion framework
I used [[https://github.com/abo-abo/swiper][ivy]] as general completion framework and [[https://github.com/company-mode/company-mode][company-mode]] as code
completion.  My completion user interface is composed of [[https://github.com/muffinmad/emacs-mini-frame][mini-frame]]
and [[https://github.com/Yevgnen/ivy-rich][ivy-rich]].

I'm using a [[https://github.com/abo-abo/swiper/issues/649][hack]] to resize minibuffer when completing with ~ivy~.

#+BEGIN_SRC emacs-lisp
(defun ta-ivy-resize--minibuffer-setup-hook ()
  "Minibuffer setup hook."
  (add-hook 'post-command-hook #'ta-ivy-resize--post-command-hook nil t))

(defun ta-ivy-resize--post-command-hook ()
  "Hook run every command in minibuffer."
  ;; ignore-errors is for handling the case where ivy do the completion
  ;; in a child frame (eg. with mini-frame-mode) where you can't `shrink-window'
  (ignore-errors (when ivy-mode
                   (shrink-window (1+ ivy-height)))))  ; Plus 1 for the input field.

(add-hook 'minibuffer-setup-hook 'ta-ivy-resize--minibuffer-setup-hook)
#+END_SRC

** fzf

#+BEGIN_SRC emacs-lisp
(require 'fzf)

;;; fzf options

(setq fzf/directory-start "~/work/")

(setq fzf/window-height 15) ; default
(setq fzf/executable "/home/tony/.linuxbrew/bin/fzf")
(setq fzf/git-grep-args "-i --line-number %s") ; default
(setq fzf/position-bottom nil) ; default

(setq fzf/with-ace-hacks t)
(setq fzf/ace-hacks-keys '(:left  ?b :right ?f :up ?p :down ?n :ace ?e))

;; fzf/args
;; 1. don't use "--reverse" argument, the way fzf/after-term-handle-exit
;;    handle the parsing to retrieve the selected file doesn't cover this case.
;; 2. "--print-query" is a mandatory argument, if you remove it, fzf/after-term-handle-exit
;;    doesn't do well its job.
(setq ta-fzf/bind
      (concat " --bind "
              "'"
              "ctrl-s:reload(fd),"                               ;; in ctrl-s 's' stands for Standard
              "ctrl-h:reload(fd --hidden --exclude \".git/*\")," ;; in ctrl-h 'h' stands for Hidden
              "ctrl-n:reload(fd --hidden --no-ignore),"          ;; in ctrl-n 'n' stands for No-ignore
              "ctrl-d:reload(fd --type d),"                      ;; in ctrl-d 'd' stands for Directory
              "ctrl-l:reload(fd --type d --hidden --no-ignore)," ;; in ctrl-l 'l' because can't take upcase 'D'
              "ctrl-f:reload(fd --type f),"                      ;; in ctrl-f 'f' stands for File
              "ctrl-b:reload(fd --type f --hidden --no-ignore)"  ;; in ctrl-b 'b' because can't take upcase 'F'
              "'"))
(setq fzf/args (concat "--print-query " ta-fzf/bind))

;;; Custom fzf command using 'fd'

(defun ta-fzf-emacs-settings ()
  "fzf in my emacs settings directory."
  (interactive)
  (let ((process-environment (cons (concat "FZF_DEFAULT_COMMAND=fd")
                                   process-environment)))
    (fzf/start "~/work/settings/emacs.d/.emacs.d/")))

(defun ta-fzf-directory ()
  "Start a fzf session frome `fzf/directory-start'."
  (interactive)
  (let ((process-environment (cons (concat "FZF_DEFAULT_COMMAND=fd")
                                   process-environment)))
    (fzf/start fzf/directory-start)))

(defun ta-fzf-default-directory ()
  "Start a fzf session at the specified directory.

Select the start directory from `default-directory'."
  (interactive)
  (let ((process-environment (cons (concat "FZF_DEFAULT_COMMAND=fd")
                                   process-environment)))
    (fzf/start (read-directory-name "Directory:" default-directory))))

(defun ta-fzf-project ()
  "Start a fzf session in current project.

If there is no current project, use the `default-directory'."
  (interactive)
  (let ((process-environment (cons (concat "FZF_DEFAULT_COMMAND=fd")
                                   process-environment)))
    (if-let ((proj (cdr (project-current))))
        (fzf/start proj)
      (fzf/start default-directory))))

(defun ta-fzf-dwim (&optional arg)
  "Start a fzf session in current project.

If there is no current project, use the `default-directory'.

With \\[universal-argument] prefix, ask to choose a directory to start fzf.
With two \\[universal-argument] prefix, start fzf at from `fzf/directory-start'."
  (interactive "p")
  (cond
   ((equal arg 4) (call-interactively 'ta-fzf-default-directory))
   ((equal arg 16) (call-interactively 'ta-fzf-directory))
   (t (call-interactively 'ta-fzf-project))))
#+END_SRC

** Discarded Packages (in the setup)
I no longer use [[https://github.com/tumashu/ivy-posframe][ivy-posframe]].  I replaced it by [[https://github.com/muffinmad/emacs-mini-frame][mini-frame]].  I seems
simpler to use and also just work fine.

| packages/modes | links        |
|----------------+--------------|
| ~ivy-posframe~   | [[https://github.com/tumashu/ivy-posframe][ivy-posframe]] |
** New Packages (in the setup)
| packages/modes         | links                  |
|------------------------+------------------------|
| ~aggressive-indent-mode~ | [[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent-mode]] |
| ~dumb-jump~              | [[https://github.com/jacktasia/dumb-jump][dumb-jump]]              |
| ~fzf.el~                 | [[https://github.com/bling/fzf.el][fzf.el]]                 |
| ~rg.el~                  | [[https://github.com/dajva/rg.el][rg.el]]                  |
| ~clojure-mode~           | [[https://github.com/clojure-emacs/clojure-mode][clojure-mode]]           |
| ~cider~                  | [[https://github.com/clojure-emacs/cider][cider]]                  |
** New commands (in the setup)
| packages/modes        | links    |
|-----------------------+----------|
| ~recenter-top-bottom~   | built-in |
| ~xref-find-definitions~ | built-in |
| ~xref-pop-marker-stack~ | built-in |
| ~counsel-rg~            | [[https://github.com/abo-abo/swiper][ivy]]      |
| ~rg-dwim~               | [[https://github.com/dajva/rg.el][rg.el]]    |
** emacs-lisp-mode
I'm using ~fuco-lisp-indent-function~ as ~lisp-indent-function~ function.
See [[https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L20-L94][fuco-lisp-indent-function]] on github.

#+BEGIN_SRC emacs-lisp
(setq lisp-indent-function 'fuco-lisp-indent-function)

(defun fuco-lisp-indent-function (indent-point state)
  "This function is the normal value of the variable `lisp-indent-function'.
The function `calculate-lisp-indent' calls this to determine
if the arguments of a Lisp function call should be indented specially.
INDENT-POINT is the position at which the line being indented begins.
Point is located at the point to indent under (for default indentation);
STATE is the `parse-partial-sexp' state for that position.
If the current line is in a call to a Lisp function that has a non-nil
property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
it specifies how to indent.  The property value can be:
- `defun', meaning indent `defun'-style
  \(this is also the case if there is no property and the function
  has a name that begins with \"def\", and three or more arguments);
- an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;
- a function to call that returns the indentation (or nil).
  `lisp-indent-function' calls this function with the same two arguments
  that it itself received.
This function returns either the indentation to use, or nil if the
Lisp function does not specify a special indentation.

Also redefines the silly indent of keyword lists:
before
  (:foo bar
        :baz qux)
after
  (:foo bar
   :baz qux)

see: https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L20-L94"
  (let ((normal-indent (current-column))
        (orig-point (point)))
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond
     ;; car of form doesn't seem to be a symbol, or is a keyword
     ((and (elt state 2)
           (or (not (looking-at "\\sw\\|\\s_"))
               (looking-at ":")))
      (if (not (> (save-excursion (forward-line 1) (point))
                  calculate-lisp-indent-last-sexp))
          (progn (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point)
                                     calculate-lisp-indent-last-sexp 0 t)))
      ;; Indent under the list or under the first sexp on the same
      ;; line as calculate-lisp-indent-last-sexp.  Note that first
      ;; thing on that line has to be complete sexp since we are
      ;; inside the innermost containing sexp.
      (backward-prefix-chars)
      (current-column))
     ((and (save-excursion
             (goto-char indent-point)
             (skip-syntax-forward " ")
             (not (looking-at ":")))
           (save-excursion
             (goto-char orig-point)
             (looking-at ":")))
      (save-excursion
        (goto-char (+ 2 (elt state 1)))
        (current-column)))
     (t
      (let ((function (buffer-substring (point)
                                        (progn (forward-sexp 1) (point))))
            method)
        (setq method (or (function-get (intern-soft function)
                                       'lisp-indent-function)
                         (get (intern-soft function) 'lisp-indent-hook)))
        (cond ((or (eq method 'defun)
                   (and (null method)
                        (> (length function) 3)
                        (string-match "\\`def" function)))
               (lisp-indent-defform state indent-point))
              ((integerp method)
               (lisp-indent-specform method state
                                     indent-point normal-indent))
              (method
               (funcall method indent-point state))))))))
#+END_SRC

** advices

#+BEGIN_SRC emacs-lisp
(defadvice isearch-occur (before ta-occur-delete-other-windows activate)
  (delete-other-windows))

(defadvice rg-run (before ta-rg-delete-other-windows activate)
  (delete-other-windows))
#+END_SRC

** Custom commands
*** Git related

#+BEGIN_SRC emacs-lisp
(defun ta-prepare-commit-msg-toggle ()
  "Set the git hook \"prepare-commit-msg\".

If it already exist (ie: not ends with \".sample\") bypass it. It is mandatory when
you rebase/rewrite your git history.
If it doesn't exist, create it with the following content:
\"
#!/bin/bash
COMMIT_MSG_FILEPATH=$1
HINT=`cat $COMMIT_MSG_FILEPATH`

echo \"Subject line\" > $COMMIT_MSG_FILEPATH
echo \"\" >> $COMMIT_MSG_FILEPATH
for cached_file in `git diff --cached --name-only | sed 's/ /\n/g'`;do
    echo \"* $cached_file:\" >> $COMMIT_MSG_FILEPATH;
done
echo \"$HINT\" >> $COMMIT_MSG_FILEPATH
\""
  (interactive)
  (when-let* ((hooks (concat (cdr (project-current)) ".git/hooks/"))
              (prepare-commit-msg (concat hooks "prepare-commit-msg")))
    (if (file-exists-p prepare-commit-msg)
        (progn (delete-file prepare-commit-msg)
               (message "\"%s\" has been removed" (file-name-nondirectory prepare-commit-msg)))
      (with-temp-file prepare-commit-msg
        (insert
         "#!/bin/bash
COMMIT_MSG_FILEPATH=$1
HINT=`cat $COMMIT_MSG_FILEPATH`

echo \"Subject line\" > $COMMIT_MSG_FILEPATH
echo \"\" >> $COMMIT_MSG_FILEPATH
for cached_file in `git diff --cached --name-only | sed 's/ /\\n/g'`;do
    echo \"* $cached_file:\" >> $COMMIT_MSG_FILEPATH;
done
echo \"$HINT\" >> $COMMIT_MSG_FILEPATH"))
      (shell-command (concat "chmod +x " prepare-commit-msg))
      (message "\"%s\" has been created" (file-name-nondirectory prepare-commit-msg)))))
#+END_SRC
*** smartparens tweak

#+BEGIN_SRC emacs-lisp
(defun indent-between-pair (&rest _ignored)
  "See: http://xenodium.com/emacs-smartparens-auto-indent/."
  (newline)
  (indent-according-to-mode)
  (forward-line -1)
  (indent-according-to-mode))

(sp-local-pair 'prog-mode "{" nil :post-handlers '((indent-between-pair "RET")))
(sp-local-pair 'prog-mode "[" nil :post-handlers '((indent-between-pair "RET")))
(sp-local-pair 'prog-mode "(" nil :post-handlers '((indent-between-pair "RET")))
#+END_SRC

*** transient command to get info

#+BEGIN_SRC emacs-lisp
;;; Get info

(declare-function transient-define-prefix "ext:transient")
(declare-function transient-define-suffix "ext:transient")
(declare-function yas-describe-tables "ext:yasnippet")

(defmacro ta-transient-define-suffix (command)
  "Create a command COMMAND--transient that is a transient suffix command
that call interactively COMMAND."
  (let ((func-name (concat (symbol-name command) "--transient")))
    `(transient-define-suffix ,(intern func-name) ()
       (interactive)
       (call-interactively (quote ,command)))))

(ta-transient-define-suffix describe-key)
(ta-transient-define-suffix describe-function)
(ta-transient-define-suffix describe-variable)
(ta-transient-define-suffix describe-mode)
(ta-transient-define-suffix yas-describe-tables)
(ta-transient-define-suffix apropos)
(ta-transient-define-suffix info)

(transient-define-prefix ta-get-info ()
  "Show menu buffer for describe commands, info commands,
apropos commands and other information about emacs."
  [["Describe"
    ("k" "describe-key" describe-key--transient)
    ("f" "describe-function" describe-function--transient)
    ("v" "describe-variable" describe-variable--transient)
    ("m" "describe-mode" describe-mode--transient)]
   ["Other info"
    ("y" "yas-describe-tables" yas-describe-tables--transient)
    ("a" "apropos" apropos--transient)
    ("i" "info" info--transient)]])

#+END_SRC

** emacs-lisp
To write my own ~emacs~ commands, I started using the following
~variables~, ~functions~, ~macros~ and ~special forms~.
*** variables
- ~process-environment~
- ~default-directory~
*** hooks
- ~post-command-hook~
- ~dired-mode-hook~
- ~minibuffer-setup-hook~
- ~window-configuration-change-hook~
*** special forms
- ~quote~
*** macros
**** from [[https://github.com/magnars/dash.el][dash]]
- ~--map~
**** from [[https://github.com/Fuco1/dired-hacks#dired-rainbow][dired-rainbow]]
- ~dired-rainbow-define-chmod~
- ~dired-rainbow-define~
**** from [[https://github.com/dajva/rg.el][rg.el]]
- ~rg-define-search~
**** from [[https://github.com/magit/transient][transient]]
- ~transient-define-prefix~
- ~transient-define-suffix~
**** built-in
- ~save-selected-window~
- ~when-let~
- ~declare-function~
- ~define-minor-mode~
- ~setq-local~
*** functions
**** from [[https://github.com/magnars/dash.el][dash]]
- ~--filter~
- ~-contains~?
- ~-elem-index~
- ~-second-item~
- ~-take~
**** from [[https://github.com/abo-abo/swiper][ivy]]
- ~ivy-done~
- ~ivy-set-action~
- ~ivy-state-caller~
**** from [[https://github.com/magnars/s.el][s]]
- ~s-split~
**** from ace-hacks
- ~ace-hacks-visite~
**** built-in
- ~add-hook~
- ~advice-add~
- ~advice-remove~
- ~alist-get~
- ~append~
- ~aref~
- ~assoc~
- ~bolp~
- ~buffer-list~
- ~buffer-narrowed-p~
- ~buffer-substring~
- ~bufferp~
- ~define-key~
- ~delete-window~
- ~dired-file-name-at-point~
- ~display-buffer-at-bottom~
- ~expand-file-name~
- ~face-attribute~
- ~frame-native-width~
- ~funcall~
- ~get-buffer-window~
- ~get-buffer-window-list~
- ~getenv~
- ~ibuffer-update~
- ~ibuffer-vc-generate-filter-groups-by-vc-root~
- ~ignore-errors~
- ~intern~
- ~isearch-yank-string~
- ~local-set-key~
- ~local-variable-p~
- ~make-local-variable~
- ~make-sparse-keymap~
- ~make-string~
- ~makunbound~
- ~nreverse~
- ~one-window-p~
- ~pop-to-buffer~
- ~project-current~
- ~provide~
- ~recenter~
- ~remove-hook~
- ~run-hook-with-args-until-success~
- ~scroll-down~
- ~scroll-other-window~
- ~scroll-other-window-down~
- ~scroll-up~
- ~scroll-up-line~
- ~select-window~
- ~self-insert-command~
- ~set-cursor-color~
- ~shrink-window~
- ~string-lessp~
- ~switch-to-buffer~
- ~symbol-name~
- ~this-command-keys-vector~
- ~windmove-down~
- ~window-body-height~
* Step 10 (July 29, 2020)
commit f760601bfc92bac7570f74396dbe1e4910af86af (v1.4.0)

I used emacs 28.50.

I started using ~subword-mode~ in ~js-mode~.  I no longer use
[[https://github.com/AndreaCrotti/yasnippet-snippets][yasnippet-snippets]].  I added some features to ~peep-dired~.

** Discarded Packages (in the setup)
I no longer use [[https://github.com/AndreaCrotti/yasnippet-snippets][yasnippet-snippets]] because most of the snippets,
althought interesting, don't fit my workflow.

| packages/modes     | links              |
|--------------------+--------------------|
| ~yasnippet-snippets~ | [[https://github.com/AndreaCrotti/yasnippet-snippets][yasnippet-snippets]] |
** New Packages (in the setup)
| packages/modes     | links              |
|--------------------+--------------------|
| ~org-indent-mode~    | built-in           |
| ~subword-mode~       | built-in           |
** emacs-lisp
To write my own ~emacs~ commands, I started using the following
~variables~, ~functions~, ~macros~ and ~special forms~.
*** functions
- ~window-list~
- ~string-equal~
- ~file-name-directory~
- ~flush-lines~
*** macros
**** from [[https://github.com/magnars/dash.el][dash]]
- ~--each~
* Step 9 (June 23, 2020 - July 01, 2020)
commit bfaa085b7e8659e1736aa54c0ce2852e2e1ceb24 (v1.3.14)

I used emacs 28.50.

I replaced ~js~ completion with [[https://github.com/ternjs/tern][tern]] and [[https://github.com/kevinushey/company-tern][company-tern]] by [[https://github.com/ananthakumaran/tide][tide]] that uses
[[https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29][tsserver]] backend.  I started using [[https://github.com/bbatsov/projectile][projectile]].  I set up the
~mode-line-format~.  I added to it the total number of lines in the
buffer.  I wrote a mini package ~quick-access~ that leverages ~ivy~
completion framework to access quickly to a bunch choosen of files.
I wrote ~ivy~ actions that leverage ~ace-window~ packages.  These actions
let you *visite* a ~file~ or a ~buffer~ (the selection) wherever you want in
your emacs layout creating appropriate window if needed.  When using
[[https://github.com/facebook/create-react-app][create-react-app]], I had some conflicts with ~lockfiles~ so I wrote a
command to toggle ~create-lockfiles~ value.  I also wrote commands to
/switch/ my keyboard-layout and to /comment/ line in ~js-jsx-mode~.

** UI
*** mode-line-format

#+BEGIN_SRC emacs-lisp
(require 'moody)
(require 'minions)
(require 'keycast)

(defun ta-number-of-lines-mode ()
  "Return the number of lines in the whole buffer."
  (interactive)
  (int-to-string (count-lines (point-min) (point-max))))

(setq-default mode-line-format
      '("%e"
       mode-line-front-space
       mode-line-mule-info
       mode-line-client
       mode-line-modified
       mode-line-remote
       mode-line-frame-identification
       mode-line-buffer-identification
       "   "
       (:eval (format "NL%s" (ta-number-of-lines-mode)))
       " "
       mode-line-position
       (vc-mode vc-mode)
       "  " mode-line-modes
       mode-line-misc-info
       mode-line-end-spaces))

(setq x-underline-at-descent-line t)
(setq minions-mode-line-lighter "")
(setq minions-mode-line-delimiters '("" . ""))
(setq moody-mode-line-height 30)
(setq keycast-separator-width 2)
(setq keycast-insert-after 'moody-mode-line-buffer-identification)
(setq keycast-window-predicate  'moody-window-active-p)

(column-number-mode -1)
(line-number-mode t)
(moody-replace-mode-line-buffer-identification)
(moody-replace-vc-mode)
(minions-mode 1)

(defun set-moody-face (frame)
  (let ((line (face-attribute 'mode-line :underline frame)))
    (set-face-attribute 'mode-line          frame :overline   line)
    (set-face-attribute 'mode-line-inactive frame :overline   line)
    (set-face-attribute 'mode-line-inactive frame :underline  line)
    (set-face-attribute 'mode-line          frame :box        nil)
    (set-face-attribute 'mode-line-inactive frame :box        nil)))

(add-to-list 'after-make-frame-functions 'set-moody-face t)
(add-to-list 'keycast-substitute-alist '(self-insert-command "." "Typing…"))
(add-to-list 'keycast-substitute-alist '(org-self-insert-command "." "Typing…"))
#+END_SRC

** Discarded Packages (in the setup)
I replaced ~js~ completion with [[https://github.com/ternjs/tern][tern]] and [[https://github.com/kevinushey/company-tern][company-tern]] by [[https://github.com/ananthakumaran/tide][tide]] that uses
[[https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29][tsserver]] backend.

| packages/modes | links        |
|----------------+--------------|
| ~company-tern~   | [[https://github.com/kevinushey/company-tern][company-tern]] |

** New Packages (in the setup)
| packages/modes     | links              |
|--------------------+--------------------|
| ~projectile~         | [[https://github.com/bbatsov/projectile][projectile]]         |
| ~company-web~        | [[https://github.com/osv/company-web][company-web]]        |
| ~ac-html-csswatcher~ | [[https://github.com/osv/ac-html-csswatcher][ac-html-csswatcher]] |
| ~tide~               | [[https://github.com/ananthakumaran/tide][tide]]               |
** New commands (in the setup)
| commands                    | packages   |
|-----------------------------+------------|
| ~projectile-find-file~        | [[https://github.com/bbatsov/projectile][projectile]] |
| ~projectile-switch-to-buffer~ | [[https://github.com/bbatsov/projectile][projectile]] |
** Custom commands
*** Comment in ~js-jsx-mode~

#+BEGIN_SRC emacs-lisp
(defun ta-jsx-uncomment-line ()
  "Comment line of elements or components in js-jsx-mode."
  (back-to-indentation)
  (save-excursion
    (delete-char 3)
    (end-of-line)
    (delete-char -3)))

(defun ta-jsx-comment-line ()
  "Uncomment line of elements or components in js-jsx-mode."
  (back-to-indentation)
  (save-excursion
    (insert "{/*")
    (end-of-line)
    (insert "*/}")))

(defun ta-jsx-comment-or-uncomment-line ()
  "Comment element in js-jsx-mode."
  (interactive)
  (back-to-indentation)
  (if (looking-at "{/\\*")
      (ta-jsx-uncomment-line)
    (ta-jsx-comment-line)))
#+END_SRC

*** ivy actions

#+BEGIN_SRC emacs-lisp
(defvar ta-ivy-aw-callers
  '(ivy-switch-buffer
    ivy-switch-buffer-other-window
    counsel-find-file
    counsel-quick-access
    projectile-completing-read)
  "List of callers used with ivy.")

(defun ta--ivy-aw-find (buffer-or-file caller)
  "Function to be used within ivy actions."
  (cond
   ((equal caller 'counsel-quick-access)
    (find-file (quick-access-get-filename buffer-or-file)))
   ((member caller '(ivy-switch-buffer ivy-switch-buffer-other-window))
    (ivy--switch-buffer-action buffer-or-file))
   ((equal caller 'projectile-completing-read)
    (find-file (projectile-expand-root buffer-or-file))
    (run-hooks 'projectile-find-file-hook))
   (t
    (find-file (expand-file-name buffer-or-file ivy--directory)))))

(defun ta--ivy-aw-find-action (buffer-or-file)
  "Action to be used in `ta-ivy-aw-find'."
  (let ((caller (ivy-state-caller ivy-last)))
    (if (not (member caller ta-ivy-aw-callers))
        (message "caller (%s) not listed in ta-ivy-aw-callers" caller)
      (call-interactively 'ace-window)
      (ta--ivy-aw-find buffer-or-file caller))))

(defun ta-ivy-aw-find ()
  "Ivy command that use ace-window to select a window and \"open\"

the selected thing. This command must be bind in ivy-minibuffer-map."
  (interactive)
  (ivy-set-action 'ta--ivy-aw-find-action)
  (ivy-done))

(defun ta--ivy-aw-find-split-up (buffer-or-file)
  "Action to be used in `ta-ivy-aw-find-split-up'."
  (let ((caller (ivy-state-caller ivy-last)))
    (if (not (member caller ta-ivy-aw-callers))
        (message "caller (%s) not listed in ta-ivy-aw-callers" caller)
      (call-interactively 'ace-window)
      (split-window-below)
      (ta--ivy-aw-find buffer-or-file caller))))

(defun ta-ivy-aw-find-split-up ()
  "Open ivy selection in the up part window selected with `ace-window'

after spliting it verticaly."
  (interactive)
  (ivy-set-action 'ta--ivy-aw-find-split-up)
  (ivy-done))

(defun ta--ivy-aw-find-split-down (buffer-or-file)
  "Action to be used in `ta-ivy-aw-find-split-down'."
  (let ((caller (ivy-state-caller ivy-last)))
    (if (not (member caller ta-ivy-aw-callers))
        (message "caller (%s) not listed in ta-ivy-aw-callers" caller)
      (call-interactively 'ace-window)
      (split-window-below)
      (windmove-down)
      (ta--ivy-aw-find buffer-or-file caller))))

(defun ta-ivy-aw-find-split-down ()
  "Open ivy selection in the down part window selected with `ace-window'

after spliting it verticaly."
  (interactive)
  (ivy-set-action 'ta--ivy-aw-find-split-down)
  (ivy-done))

(defun ta--ivy-aw-find-split-left (buffer-or-file)
  "Action to be used in `ta-ivy-aw-find-split-left'."
  (let ((caller (ivy-state-caller ivy-last)))
    (if (not (member caller ta-ivy-aw-callers))
        (message "caller (%s) not listed in ta-ivy-aw-callers" caller)
      (call-interactively 'ace-window)
      (split-window-right)
      (ta--ivy-aw-find buffer-or-file caller))))

(defun ta-ivy-aw-find-split-left ()
  "Open ivy selection in the left part window selected with `ace-window'

after spliting it horizontaly."
  (interactive)
  (ivy-set-action 'ta--ivy-aw-find-split-left)
  (ivy-done))

(defun ta--ivy-aw-find-split-right (buffer-or-file)
  "Action to be used in `ta-ivy-aw-find-split-right'."
  (let ((caller (ivy-state-caller ivy-last)))
    (if (not (member caller ta-ivy-aw-callers))
        (message "caller (%s) not listed in ta-ivy-aw-callers" caller)
      (call-interactively 'ace-window)
      (split-window-right)
      (windmove-right)
      (ta--ivy-aw-find buffer-or-file caller))))

(defun ta-ivy-aw-find-split-right ()
  "Open ivy selection in the righ part window selected with `ace-window'

after spliting it horizontaly."
  (interactive)
  (ivy-set-action 'ta--ivy-aw-find-split-right)
  (ivy-done))

(defun ta-ivy-switch-to-buffer ()
  "Wrapper on `switch-to-buffer' to be used in `ivy-minibuffer-map'."
  (interactive)
  (ivy-set-action 'ivy--switch-buffer-action)
  (ivy-done))

(define-key ivy-minibuffer-map (kbd "C-e") 'ta-ivy-aw-find)
(define-key ivy-minibuffer-map (kbd "C-p") 'ta-ivy-aw-find-split-up)
(define-key ivy-minibuffer-map (kbd "C-n") 'ta-ivy-aw-find-split-down)
(define-key ivy-minibuffer-map (kbd "C-b") 'ta-ivy-aw-find-split-left)
(define-key ivy-minibuffer-map (kbd "C-f") 'ta-ivy-aw-find-split-right)
(define-key ivy-minibuffer-map (kbd "C-a") 'ta-ivy-switch-to-buffer)
#+END_SRC

*** Keyboard layout

#+BEGIN_SRC emacs-lisp
(defun ta-switch-keyboard-layout ()
  "Switch keyboard layout variant between\"takbl\" and \"takbl fr\"."
  (interactive)
  (let ((variant (shell-command-to-string "setxkbmap -query | grep variant | awk -F' '  '{ print $2 }'")))
    (if (string= variant "fr\n")
        (progn
          (shell-command-to-string "setxkbmap -layout takbl")
          (message "takbl"))
      (shell-command-to-string "setxkbmap -layout takbl -variant fr")
      (message "takbl - fr"))))
#+END_SRC

*** Mark things

#+BEGIN_SRC emacs-lisp
(defun ta-point-in-string-p (pt)
  "Returns t if PT is in a string"
  (eq 'string (syntax-ppss-context (syntax-ppss pt))))

(defun ta-goto-begining-of-string (pt)
  "Go to begining of the string if PT is inside a string.
Return nil if PT isn't inside a string. See the function `ta-point-in-string-p'"
  (if (ta-point-in-string-p pt)
      (goto-char (nth 8 (syntax-ppss pt)))
    nil))

(defun ta-mark-inside-pairs ()
  "An other way to do `er/mark-inside-pairs' but work for sgml-tag too."
  (interactive)
  (ta-goto-begining-of-string (point))
  ;; todo: do thing when inside a tag <tag name="tony"> (maybe use the function sgml-begining-of-tag)
  (sp-backward-up-sexp)
  (sp-mark-sexp)
  (sp-down-sexp)
  (exchange-point-and-mark)
  (sp-backward-down-sexp)
  (exchange-point-and-mark))

(defun ta-mark-inside-quotes-or-pairs (&optional arg)
  "Mark inside quotes calling `er/mark-inside-quotes'.

When ARG is 4, mark inside pairs calling `ta-mark-inside-pairs'."
  (interactive "p")
  (if (equal arg 4)
      (call-interactively 'ta-mark-inside-pairs)
    (call-interactively 'er/mark-inside-quotes)))
#+END_SRC

*** Miscellaneous

#+BEGIN_SRC emacs-lisp
(defun ta-copy-buffer-file-name ()
  "Push current `buffer-file-name' to the `kill-ring'."
  (interactive)
  (kill-new (buffer-file-name)))

(defun ta-toggle-create-lockfiles ()
  "Toggle the value of `create-lockfiles' interactively."
  (interactive)
  (setq create-lockfiles (not create-lockfiles))
  (message "create-lockfiles set to: %s" create-lockfiles))
#+END_SRC

** advices
I removed the advice on ~back-to-indentation~ command that pushes the
mark because it seems that ~back-to-indentation~ is called each time you
use ~org-self-insert-command~ in ~org-mode~.  This causes to call
~push-mark~ every time you insert a character which is really bad.

#+BEGIN_SRC emacs-lisp
# I removed this advice
(defadvice back-to-indentation (before back-to-indentation-advice activate)
  (if (not mark-active) (push-mark)))
#+END_SRC

** Custom packages
*** quick-access

#+BEGIN_SRC emacs-lisp
(declare-function ivy-read "ext:ivy")

(defvar quick-access-alist ()
  "Association list of quick-access names and its full filename.

The value is an alist with quick-access of the form

 (QUICK-ACCESS-NAME . FILENAME).

QUICK-ACCESS-NAME must be uniq.")

(defun quick-access-all-names ()
  "Return the list of all the quick-access-name define in `quick-access-alist'."
  (-map 'car quick-access-alist))

(defun quick-access-get-filename (quick-access-name)
  "Return the full filename of QUICK-ACCESS-NAME, or nil if none."
  (assoc-default quick-access-name quick-access-alist))

(defun counsel-quick-access ()
  "Open a quick-access file listed in `quick-access-alist'."
  (interactive)
  (ivy-read "Open quick-access: "
            (quick-access-all-names)
            :history 'quick-access-history
            :action (lambda (x)
                      (find-file (quick-access-get-filename x)))
            :caller 'counsel-quick-access))


(provide 'quick-access)
#+END_SRC

** emacs-lisp
To write my own ~emacs~ commands, I started using the following
~variables~, ~functions~, ~macros~ and ~special forms~.
*** functions
**** from [[https://github.com/magnars/dash.el][dash]]
- ~-map~
**** from [[https://github.com/abo-abo/swiper][ivy]]
- ~ivy-read~
**** built-in
- ~assoc-default~
- ~get-buffer-window~
- ~kill-new~
- ~string=~
- ~shell-command-to-string~
- ~count-lines~
* Step 8 (June 12, 2020 - June 22, 2020)
commit d80d9be33cdb0c756f510820a9888d4e298f914d (v1.3.12)

I used emacs 28.50.

I tweaked a command around the command ~bicycle-cycle-global~ and I used
~counsel-outline~ to navigate any code as if I was in ~org-mode~.  I
started using ~clone-indirect-buffer-other-window~ that creates an
indirect buffer that is a twin copy of the current buffer.  It allows
you to see two different parts of a same files at the same time and
side by side.  I used an ~hydra~ for commands that apply in ~sgml-mode~.
My completion user interface is composed of [[https://github.com/tumashu/ivy-posframe][ivy-posframe]] and [[https://github.com/Yevgnen/ivy-rich][ivy-rich]].
I started using [[https://github.com/tarsius/keycast][keycast]] that displays the command and event in the
~mode-line~.  I wrote commands that, when you are in a ~dired~ buffer, let
you visite a file that you place wherever you want in your emacs
layout leveraging [[https://github.com/abo-abo/ace-window][ace-window]] package.

** Completion framework
I used [[https://github.com/abo-abo/swiper][ivy]] as general completion framework and [[https://github.com/company-mode/company-mode][company-mode]] as code
completion.  My completion user interface is composed of [[https://github.com/tumashu/ivy-posframe][ivy-posframe]]
and [[https://github.com/Yevgnen/ivy-rich][ivy-rich]].
** UI

#+BEGIN_SRC emacs-lisp
(setq linum-format " %7i ")
(setq frame-resize-pixelwise t)
#+END_SRC

** dired-mode

#+BEGIN_SRC emacs-lisp
(require 'dired)
(require 'dired-hacks-utils)
(require 'dired-subtree)
(require 'dired-narrow)
(require 'dired-hide-dotfiles)
(require 'dired-open)
(require 's)
(require 'dash)
(require 'dired-hacks-utils)
(require 'dired-toggle-sudo)
(require 'dired-collapse)
(require 'wdired)
(require 'dired-x)
(require 'peep-dired)
(require 'dired-rainbow)

(dired-hide-dotfiles-mode)

(setq dired-keep-marker-rename t)
(setq wdired-allow-to-change-permissions nil)
(setq wdired-create-parent-directories t)
(setq dired-narrow-exit-when-one-left t)
(setq dired-clean-up-buffers-too t)
(setq dired-clean-confirm-killing-deleted-buffers t)
(setq dired-dwim-target t)
(setq dired-recursive-copies 'always)
(setq dired-recursive-deletes 'always)
(setq-default dired-listing-switches "-lhAX --group-directories-first")
(setq dired-open-extensions
      '(("pdf" . "evince")
        ("jpg" . "eog")
        ("png" . "eog")))
(setq-default dired-subtree-line-prefix "  ")
(setq-default dired-subtree-use-backgrounds nil)
(setq peep-dired-cleanup-on-disable t)
(setq peep-dired-cleanup-eagerly nil)
(setq peep-dired-enable-on-directories nil)
(setq peep-dired-ignored-extensions
      '("mkv" "webm" "mp4" "mp3" "ogg" "iso" "pdf"))

(declare-function ace-window "ext:ace-window")

(defun ta-dired-aw-find-file ()
  "Open file at point in window selected with `ace-window'."
  (interactive)
  (let ((file-at-point (dired-file-name-at-point)))
    (call-interactively 'ace-window)
    (if file-at-point (find-file (expand-file-name file-at-point)))))

(defun ta-dired-aw-find-file-split-down ()
  "Open file at point in the part below window selected after

spliting it verticaly."
  (interactive)
  (let ((file-at-point (dired-file-name-at-point)))
    (call-interactively 'ace-window)
    (split-window-below)
    (recenter)
    (windmove-down)
    (recenter)
    (if file-at-point (find-file (expand-file-name file-at-point)))))

(defun ta-dired-aw-find-file-split-up ()
  "Open file at point in the part up window selected after

spliting it verticaly."
  (interactive)
  (let ((file-at-point (dired-file-name-at-point)))
    (call-interactively 'ace-window)
    (split-window-below)
    (recenter)
    (if file-at-point (find-file (expand-file-name file-at-point)))))

(defun ta-dired-aw-find-file-split-right ()
  "Open file at point in window at the right selected with `ace-window'

and splited horizontaly."
  (interactive)
  (let ((file-at-point (dired-file-name-at-point)))
    (call-interactively 'ace-window)
    (split-window-right)
    (recenter)
    (windmove-right)
    (recenter)
    (if file-at-point (find-file (expand-file-name file-at-point)))))

(defun ta-dired-aw-find-file-split-left ()
  "Open file at point in window at the left selected with `ace-window'

and splited horizontaly."
  (interactive)
  (let ((file-at-point (dired-file-name-at-point)))
    (call-interactively 'ace-window)
    (split-window-right)
    (recenter)
    (if file-at-point (find-file (expand-file-name file-at-point)))))

(defun ta-dired-subtree-toggle-all ()
  "Apply `dired-subtree-toggle' to all root directories

in the dired buffer"
  (interactive)
  (setq deactivate-mark t)
  (save-excursion
    (cond
     ((eq last-command 'dired-subtree-toggle-overview)
      (goto-char (point-min))
      (next-line)
      (while (not (eobp))
        (if (dired-utils-is-dir-p) (dired-subtree-toggle))
        (dired-subtree-next-sibling))
      (message "ALL"))
     ((eq last-command 'ta-dired-subtree-toggle-all)
      (goto-char (point-min))
      (next-line)
      (while (not (eobp))
        (if (dired-utils-is-dir-p) (dired-subtree-toggle))
        (dired-subtree-next-sibling))
      (message "ALL"))
     (t
      (goto-char (point-max))
      (previous-line)
      (setq number-line-before-remove (line-number-at-pos))
      (dired-subtree-remove)
      (while (not (bobp))
        (while (not (equal number-line-before-remove (line-number-at-pos)))
          (setq number-line-before-remove (line-number-at-pos))
          (dired-subtree-remove))
        (previous-line))
      (message "OVERVIEW")
      (setq this-command 'dired-subtree-toggle-overview)))))

(defun ta-dired-width (dir)
  "Return the number of characters of the bigger file or directory in

a dired buffer generate with DIR as `dired-directory'."
  (with-current-buffer (dired-noselect dir)
    (-max (--map (length (-last-item (s-split "/" it)))
                 (dired-utils-get-all-files)))))

(defun ta-sidebar ()
  "Pop a buffer on the left of the frame in `dired-mode'

with the parent directory of the current `buffer-file-name' if non-nil
or, your home directory \"~/\".

If the frame contains buffers in `dired-mode', delete them."
  (interactive)
  (let ((initial-window (selected-window))
        dired-window-deleted-p
        buff-file-name)
    (--each (window-list)
      (select-window it)
      (if (string-equal major-mode "dired-mode")
          (progn (delete-window) (setq dired-window-deleted-p t))))
    (unless dired-window-deleted-p
      (select-window initial-window)
      (delete-other-windows)
      (setq buff-file-name
            (file-name-directory (cond (buffer-file-name) ("~/"))))
      (let ((width (ta-dired-width buff-file-name)))
        (split-window-right (+ 10 width))) ; 10 is arbitrary
      (dired buff-file-name))))

(define-minor-mode dired-header-line-mode
  "Show only the last two directories of the path to the current directory
that `dired-mode' is displaying."
  :init-value nil :group 'header-line :group 'dired
  (unless (derived-mode-p 'dired-mode)
    (error "You must be in Dired or a mode derived from it to use this command"))
  (if dired-header-line-mode
      (progn
        (setq path-len (length (s-split "/" (expand-file-name dired-directory))))
        (setq header-line-directories
              (car (last (s-split-up-to "/" (expand-file-name dired-directory)
                                        (- path-len 3)))))
        (setq header-line-format (concat " ↪[" header-line-directories "]")))
    (setq header-line-format  (default-value 'header-line-format))))

(defface ta-dired-header-face nil
  "Face for dired header, first line of buffer in `dired-mode'"
  :group 'dired)

(font-lock-add-keywords
 'dired-mode
 '(("\\(^.*:$\\)" . 'ta-dired-header-face)))

(font-lock-add-keywords
 'wdired-mode
 '(("\\(^.*:$\\)" . 'ta-dired-header-face)))

;; see discreet-theme.el
(dired-rainbow-define-chmod executable-unix "#7fffd4" "-.*x.*")
(dired-rainbow-define media "#d4fbcb"
                      ("mp3" "mp4" "MP3" "MP4" "avi" "mpg" "flv" "ogg" "m4a"))
(dired-rainbow-define image "#a4c30d" ("jpg" "jpeg" "png"))
(dired-rainbow-define svg "#8a510f" ("svg"))
(dired-rainbow-define media-editing "#e421e8" ("kdenlive" "aup"))
(dired-rainbow-define plain-text "#ffd500" ("org" "md"))
(dired-rainbow-define emacs-lisp "#00bdd6" ("el"))
(dired-rainbow-define python "#d16500" ("py"))
(dired-rainbow-define js "#bb8415" ("js"))
(dired-rainbow-define shadow (:inherit shadow) "\\.git.*" )

(add-hook 'dired-mode-hook (lambda () (dired-hide-details-mode 1)))
(add-hook 'dired-before-readin-hook 'dired-header-line-mode)

#+END_SRC

** hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-sgml
  (:pre (hydra-color-pre-sgml)
   :post (hydra-color-post)
   :hint nil)
  ("t" hydra-sp/body :color blue)
  ("DEL" sgml-delete-tag)
  ("p" ta-previous-attribute)
  ("n" ta-next-attribute)
  ("b" emmet-prev-edit-point)
  ("f" emmet-next-edit-point)
  ("&" sgml-namify-char)
  ("." emmet-wrap-with-markup)
  ("c" sgml-close-tag)
  ("e" emmet-expand-yas)
  ("i" emmet-expand-line)
  ;; ---
  ("g" cleanup-buffer)
  ("M--" undo)
  ("q" nil))
#+END_SRC

** Discarded Packages (in the setup)
I no longer use [[https://github.com/purcell/diredfl][diredfl]].  I prefer using ~dired-rainbow~ from
[[https://github.com/Fuco1/dired-hacks][dired-hacks]].

| packages/modes | links   |
|----------------+---------|
| ~diredfl~        | [[https://github.com/purcell/diredfl][diredfl]] |
** New Packages (in the setup)
| packages/modes | links    |
|----------------+----------|
| keycast        | [[https://github.com/tarsius/keycast][keycast]]  |
| ivy-rich       | [[https://github.com/Yevgnen/ivy-rich][ivy-rich]] |
** New commands (in the setup)
| commands                           | packages |
|------------------------------------+----------|
| ~clone-indirect-buffer-other-window~ | built-in |
| ~counsel-outline~                    | [[https://github.com/abo-abo/swiper][ivy]]      |
** Custom commands
*** Outline

#+BEGIN_SRC emacs-lisp
(defun ta-outline-toggle-global ()
  "Toggle visibility of all outline (see `outline-mode') sections.

This command toggle between this following levels:
1. TREES:    Show all headings, treaing top-level code blocks
             as sections (i.e. their first line is treated as
             a heading).
2. ALL:      Show everything, except code blocks that have been
             collapsed individually (using a `hideshow' command
             or function).

This is a variant off the `bicycle-cycle-global' with two
level less."
  (interactive)
  (setq deactivate-mark t)
  (save-excursion
    (goto-char (point-min))
    (unless (re-search-forward outline-regexp nil t)
      (user-error "Found no heading"))
    (cond
     ((eq last-command 'outline-cycle-trees)
      (outline-show-all)
      (bicycle--message "ALL"))
     (t
      (outline-hide-sublevels (bicycle--level))
      (outline-map-region
       (lambda ()
         (when (bicycle--top-level-p)
           (outline-show-branches)))
       (point-min)
       (point-max))
      (bicycle--message "TREES")
      (setq this-command 'outline-cycle-trees)))))
#+END_SRC

*** Miscellaneous

#+BEGIN_SRC emacs-lisp
(defun ta--dired-side-by-side (current-directory)
  "Do the layout job of `ta-dired-side-by-side'."
  (delete-other-windows)
  (dired current-directory)
  (split-window-right))

(defun ta-dired-side-by-side ()
  "Pop two dired buffer side by side.

If `current-buffer' is visiting a file, the root directory of this
file becomes `dired-directory' of the popped dired buffers. If not
visiting a file, the $HOME directory is chosen to be the
`dired-directory'"
  (interactive)
  (let ((current-buffer-file-name (buffer-file-name))
        (current-dired-directory dired-directory))
    (cond
     (current-buffer-file-name
      (ta--dired-side-by-side (file-name-directory current-buffer-file-name)))
     (current-dired-directory
      (ta--dired-side-by-side current-dired-directory))
     (t
      (ta--dired-side-by-side (expand-file-name "~/"))))))
#+END_SRC

** advices

#+BEGIN_SRC emacs-lisp
(defadvice clone-indirect-buffer-other-window
    (after ta-clone-indirect-buffer-other-window-advice activate)
  (recenter))
#+END_SRC

** emacs-lisp
To write my own ~emacs~ commands, I started using the following
~variables~, ~functions~, ~macros~ and ~special forms~.
*** functions
- ~point-min~
- ~point-max~
- ~deactivate-mark~
- ~outline-show-all~
* Step 7 (June 11, 2020)
commit 534087a4e106a6c72186ea0ec6b41b983a210d9e (v1.3.7)

I wrote ~framer~, my first package.  It's a kind undo package for windows
layout in frame that doesn't lost the layout when the frame dies.  It
uses ~ring~ built-in package.

** Custom package
*** framer

#+BEGIN_SRC emacs-lisp
(require 'ring)

(defvar framer-ring-size 10)
(defvar framer-ring nil)
(defvar framer-undo-counter nil)
(defvar framer-redo-frame nil)

(defun framer-set-ring ()
  "Initialize `framer-ring' to an empty ring if not define yet."
  (unless framer-ring
    (setq framer-ring (make-ring framer-ring-size))))

(defun framer-flush ()
  "Flush `framer-ring'."
  (interactive)
  (setq framer-ring (make-ring framer-ring-size)))

(defun framer-push ()
  "Push the window's state into `framer-ring'."
  (interactive)
  (framer-set-ring)
  (ring-insert framer-ring (window-state-get)))

(defun framer-undo ()
  "Cycle through `framer-ring'."
  (interactive)
  (unless (eq last-command 'framer-undo)
    (setq framer-redo-frame (window-state-get))
    (setq framer-undo-counter 0)
    (framer-set-ring))
  (unless (ring-empty-p framer-ring)
    (window-state-put (ring-ref framer-ring framer-undo-counter))
    (cl-incf framer-undo-counter)))

(defun framer-redo ()
  "Go back to the last window's state before start to

cycling in `framer-ring' with `framer-undo'."
  (interactive)
  (if (eq last-command 'framer-undo)
      (window-state-put framer-redo-frame)))


(provide 'framer)
#+END_SRC

** emacs-lisp
To write my own ~emacs~ commands, I started using the following
~variables~, ~functions~, ~macros~ and ~special forms~.
*** functions
- ~make-ring~
- ~ring-insert~
- ~window-state-get~
- ~ring-empty-p~
- ~window-state-put~
- ~ring-ref~
*** macros
- ~cl-incf~
*** variables
- ~last-command~

* Step 6 (February 2020 - June 10, 2020)
commit 3f93d24627cb312f18f23e0e4a3ee782acb7c836 (v1.3.6)

I used emacs 28.50.

I started customizing ~display-buffer-alist~.  This gave me more control
of my emacs layout that is more predictable.  I used ~peep-dired~ to
browse file at a glance in directories.  This is really effective to
discover new projects.  I forked [[https://github.com/tonyaldon/peep-dired][peep-dired]] and started working on my
own features.  I started using ~iy-go-to-char~ that brings short movement
to another level.  I started using ~outline-minor-mode~.  This is really
handy to navigate your code and to get a quick overview of the content
in a file.  I switched from ~shell~ to ~term~.  I started using ~recentf~.
I started using ~magit~.  Althought I only use the basics of ~magit~, it's
really change the game of ~git~.  I wrote two commands for navigating to
the next or previous attribute in ~sgml-mode~.  I learnt a lot on
/regexp/.  I wrote a /custom/ ~newline~ command for ~make-mode~.  I think this
was the first time I understood that any key, including ~RET,~ is bound
to a command and so can do anything.  I wrote a /minor mode/ for ~i3~
config files that just /fontify/ some /keywords/.

** Problems
I had some problems with the key binding ~M-[~ when I was using ~emacs~
inside a ~TTY~ (without windows).  I couldn't figure out what was the
problem, so I stop using this binding.

I had some problems with dead keys.  I don't find a better solution
that stopped binding dead keys.
** Miscellaneous

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-chromium)
(setq backup-directory-alist '(("." . "~/.emacs.d/backup")))

(setq-default tab-width 2)

(set-language-environment "UTF-8")

(setenv "PATH" (concat "~/.local/bin:" (getenv "PATH")))
(add-to-list 'exec-path "~/.local/bin")

(add-to-list `auto-mode-alist '("\\.svg\\'" . fundamental-mode))

(recentf-mode 1)
(setq recentf-save-file "~/.emacs.d/recentf")
(setq recentf-max-saved-items 25)

(setq save-interprogram-paste-before-kill t)
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Installation
I use ~make~ and ~Makefile~ to install ~emacs~ and ~Cask~.
** UI

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :family "DejaVu Sans Mono")
(set-fontset-font t 'unicode "Symbola" nil 'prepend)

(setq inhibit-startup-screen t)
(setq frame-title-format
      '(buffer-file-name "%f" (dired-directory dired-directory "%b")))

(setq-default cursor-type '(bar . 2))
(blink-cursor-mode -1)
(make-variable-buffer-local 'global-hl-line-mode)

(add-hook 'help-mode-hook (lambda () (visual-line-mode t)))
(setq
 display-buffer-alist
 '(("\\*Help.*"
    (display-buffer-in-side-window)
    (window-width . 0.3)
    (side . left)
    (slot . -1))
   ("\\*Messages.*\\|\\*Warnings.*\\|\\*Backtrace.*\\|*Apropos.*"
    (display-buffer-in-side-window)
    (window-width . 0.3)
    (side . left)
    (slot . 1))
   ("\\*info.*"
    (display-buffer-in-side-window)
    (window-width . 0.36)
    (side . left)
    (slot . 1))
   ("*scratch.*\\|*YASnippet Tables by NAMEHASH*\\|*YASnippet Tables*"
    (display-buffer-in-side-window)
    (window-width . 0.3)
    (side . left)
    (slot . 2))
   ("\\*.*occur.*\\|\\*grep.*"
    (display-buffer-in-side-window)
    (window-height . 0.3)
    (side . top)
    (slot . 1))
   ("\\*terminal.*"
    (display-buffer-in-side-window)
    (window-height . 0.25)
    (side . top)
    (slot . -1))
   ("magit:.*\\|magit-diff:.*"
    (display-buffer-in-direction)
    (direction . left))
   ("magit-log:.*"
    (display-buffer-below-selected))))

#+END_SRC

** dired-mode

#+BEGIN_SRC emacs-lisp
(require 'dired)
(require 'dired-subtree)
(require 'dired-narrow)
(require 'dired-hide-dotfiles)
(require 'dired-open)
(require 's)
(require 'dash)
(require 'dired-hacks-utils)
(require 'dired-toggle-sudo)
(require 'dired-collapse)
(require 'wdired)
(require 'dired-x)
(require 'diredfl)
(require 'peep-dired)

(dired-hide-dotfiles-mode)

(setq dired-keep-marker-rename t)
(setq wdired-allow-to-change-permissions nil)
(setq wdired-create-parent-directories t)
(setq dired-narrow-exit-when-one-left t)
(setq dired-clean-up-buffers-too t)
(setq dired-clean-confirm-killing-deleted-buffers t)
(setq dired-dwim-target t)
(setq dired-recursive-copies 'always)
(setq dired-recursive-deletes 'always)
(setq-default dired-listing-switches "-lhA --group-directories-first")
(setq dired-open-extensions
      '(("pdf" . "evince")
        ("jpg" . "eog")
        ("png" . "eog")))
(setq-default dired-subtree-line-prefix "  ")
(setq-default dired-subtree-use-backgrounds nil)
(setq peep-dired-cleanup-on-disable t)
(setq peep-dired-cleanup-eagerly nil)
(setq peep-dired-enable-on-directories nil)
(setq peep-dired-ignored-extensions
        '("mkv" "webm" "mp4" "mp3" "ogg" "iso" "pdf"))

(defun ta-size-bigger-file-or-directory-in-dired ()
  "Return the number of characters of the bigger FILE-OR-DIRECTORY in current dired buffer."
  (with-current-buffer (current-buffer)
    (-max (--map (length (-last-item (s-split "/" it)))
                 (dired-utils-get-all-files)))))

(defun ta-sidebar ()
  "Pop a buffer on the left of the frame in `dired-mode'

with the parent directory of the current `buffer-file-name' if not `nil' and
if the frame contains any buffer in `dired-mode'. If the frame contains buffers
in `dired-mode', delete them.
"
  (interactive)
  ;; TODO: - check the case of buffer-file-name is nil
  ;; TODO: - check the case of the is only one buffer in dired-mode
  (setq current-window (car (avy-window-list)))
  (setq window-list (avy-window-list))
  (setq dired-buffer-into-frame-p nil)
  (while window-list
    (select-window (car window-list))
    (if (string-equal major-mode "dired-mode")
        (progn
          (setq dired-buffer-into-frame-p t)
          (delete-window)))
    (setq window-list (cdr window-list)))
  (if dired-buffer-into-frame-p
      nil
    (select-window current-window)
    (delete-other-windows)
    (let ((width (with-current-buffer
                     (dired-noselect (file-name-directory (buffer-file-name)))
                   (ta-size-bigger-file-or-directory-in-dired))))
      (split-window-right (+ 10 width))) ; 10 is arbitrary
    (dired (file-name-directory (buffer-file-name)))))

(define-minor-mode dired-header-line-mode
  "Show only the last two directories of the path to the current directory
that `dired-mode' is displaying."
  :init-value nil :group 'header-line :group 'dired
  (unless (derived-mode-p 'dired-mode)
    (error "You must be in Dired or a mode derived from it to use this command"))
  (if dired-header-line-mode
      (progn
        (setq path-len
              (length
               (s-split "/" (expand-file-name dired-directory))))
        (setq header-line-directories
              (car
               (last
                (s-split-up-to "/" (expand-file-name dired-directory)
                 (- path-len 3)))))
        (setq header-line-format (concat "..." header-line-directories)))
    (setq header-line-format  (default-value 'header-line-format))))

(defface ta-dired-header-face
  nil
  "Face for dired header, first line of buffer in `dired-mode'"
  :group 'dired)

(font-lock-add-keywords
 'dired-mode
 '(("\\(^.*:$\\)" . 'ta-dired-header-face)))

(font-lock-add-keywords
 'wdired-mode
 '(("\\(^.*:$\\)" . 'ta-dired-header-face)))

(add-hook 'dired-mode-hook 'diredfl-mode)
(add-hook 'dired-mode-hook (lambda () (dired-hide-details-mode 1)))
(add-hook 'dired-before-readin-hook 'dired-header-line-mode)
#+END_SRC
** Project management tool
I use [[https://github.com/cask/cask][Cask]] as project management tool.
** Discarded Packages (in the setup)
I stopped using ~ivy-posframe~.  I removed ~minimap~ package because I
wasn't using it.  I didn't find it useful to code.

| packages/modes | links        |
|----------------+--------------|
| ~ivy-posframe~   | [[https://github.com/tumashu/ivy-posframe][ivy-posframe]] |
| ~minimap~        | [[https://github.com/dengste/minimap][minimap]]      |
** New Packages (in the setup)
| packages/modes     | links             |
|--------------------+-------------------|
| ~outline-minor-mode~ | built-in          |
| ~recentf~            | built-in          |
| ~sql~                | built-in          |
| ~bicycle~            | [[https://github.com/tarsius/bicycle][bicycle]]           |
| ~cask~               | [[https://github.com/cask/cask][Cask]]              |
| ~company-emoji~      | [[https://github.com/dunn/company-emoji][company-emoji]]     |
| ~dired-collapse~     | [[https://github.com/Fuco1/dired-hacks][dired-hacks]]       |
| ~dired-toggle-sudo~  | [[https://github.com/renard/dired-toggle-sudo][dired-toggle-sudo]] |
| ~diredfl~            | [[https://github.com/purcell/diredfl][diredfl]]           |
| ~iy-go-to-char~      | [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]]     |
| ~magit~              | [[https://github.com/magit/magit][magit]]             |
| ~peep-dired~         | [[https://github.com/asok/peep-dired][peep-dired]]        |
| ~sql-indent~         | [[https://github.com/alex-hhh/emacs-sql-indent][sql-indent]]        |
| ~sqlup-mode~         | [[https://github.com/Trevoke/sqlup-mode.el][sqlup-mode]]        |
** New commands (in the setup)
| commands               | packages      |
|------------------------+---------------|
| undo-redo              | built-in      |
| query-replace-regexp   | built-in      |
| iy-go-to-char          | [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]] |
| iy-go-to-char-backward | [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]] |
| magit-status           | [[https://github.com/magit/magit][magit]]         |
** Custom commands
*** Describe

#+BEGIN_SRC emacs-lisp
(defun ta-describe-thing-at-point ()
  "Display the full documentation of the `thing-at-point'

that is either a function or a variable.
Return nil if the symbol of the `thing-at-point' is neither a function
nor a variable."
  (interactive)
  (let ((current-symbol (symbol-at-point)))
    (cond
     ((not current-symbol))
     ((boundp current-symbol) (describe-variable current-symbol))
     ((fboundp current-symbol) (describe-function current-symbol))
     (t (message "The symbol-at-point is neither a variable or a function")))))
#+END_SRC

*** emacs-lisp-mode

#+BEGIN_SRC emacs-lisp
(declare-function yas-expand "ext:yasnippet")

(defun ta-defun-above ()
  "Expand the `def' yasnippet above the current root node.

Before doing so, push `symbol-at-point' into the `kill-ring'.
See `yas-expand'. "
  (interactive)
  (if (symbol-at-point) (kill-new (symbol-name (symbol-at-point))))
  (re-search-backward "^[(]" nil t)
  (open-line 2)
  (insert "def")
  (call-interactively 'yas-expand))
#+END_SRC

*** make-mode

#+BEGIN_SRC emacs-lisp
(defun ta-newline-smart ()
  "Perform `newline-and-indent' or `newline' depending of the context."
  (interactive)
  (if (looking-back "\t")
      (progn (delete-char -1) (newline))
    (if (looking-back "\n\n")
        (newline)
      (newline)
      (indent-for-tab-command))))

(define-key makefile-gmake-mode-map (kbd "RET") 'ta-newline-smart)
#+END_SRC

*** sgml-mode

#+BEGIN_SRC emacs-lisp
(defconst ta-sgml-attr-value-re "\\(?:[^\"'/><]\\|\"[^\"]*\"\\|'[^']*'\\)")
(defconst ta-sgml-name-re sgml-name-re)
(defconst ta-sgml-attr-re
  (concat "[[:space:]]\\{1\\}" ta-sgml-name-re "=" ta-sgml-attr-value-re))


(defun ta-next-attribute ()
  "Move forward to the next attribute"
  (interactive)
  (save-excursion (setq beg-of-tag (sgml-beginning-of-tag)))
  (if beg-of-tag
      (progn
        (looking-at "\\(/>\\|>\\)")
        (let ((end-of-tag-symbol (match-string 0)))
          (cond
           ((equal end-of-tag-symbol "/>") (forward-char 2))
           ((equal end-of-tag-symbol ">") (forward-char 1))
           (t (let ((end-of-tag
                     (save-excursion
                       (sgml-tag-end (car (sgml-get-context))))))
                (if (search-forward-regexp ta-sgml-attr-re end-of-tag t)
                    (progn (goto-char (match-beginning 0))
                           (forward-char 1))
                  (goto-char end-of-tag)
                  (if (looking-back "/>")
                      (backward-char 2)
                    (backward-char 1))))))))
    ;;2nd if part
    (search-forward-regexp sgml-tag-name-re nil t)
    (let ((tag-type (substring (match-string 0) 0 2)))
      (if (equal tag-type "</")
          (sgml-skip-tag-forward 1)
        (unless (looking-at ">")
          (progn
            (search-forward-regexp ta-sgml-attr-re nil t)
            (goto-char (match-beginning 0))
            (forward-char 1)))))))

(defun ta-previous-attribute ()
  "Move forward to the next attribute"
  (interactive)
  (save-excursion
    (setq inside-tag (sgml-beginning-of-tag))
    (if inside-tag (setq beg-of-tag (point))))
  (if inside-tag
      (if (search-backward-regexp ta-sgml-attr-re beg-of-tag t)
          (forward-char 1)
        (goto-char beg-of-tag))
    (search-backward-regexp ">" nil t)
    (save-excursion (setq tag-type
                          (sgml-tag-type (car (sgml-get-context)))))
    (cond
     ((equal tag-type 'empty) (backward-char 1))
     ((equal tag-type 'close) (sgml-beginning-of-tag)))))
#+END_SRC

** advices

#+BEGIN_SRC emacs-lisp
(defadvice windmove-do-window-select
    (before windmove-do-window-select-advice activate)
  "Push `selected-window' in the ring used by `aw-flip-window'.

The function `windmove-left', `windmove-right', `windmove-up' and
`windmove-down' are interactive wrappers to `windmove-do-window-select'."
  (aw--push-window (selected-window)))

(defadvice sgml-delete-tag (after sgml-delete-tag-advice activate)
  (indent-buffer))

(defadvice magit-status (before ta-magit-status-advice activate)
  (unless (s-contains-p "magit" (buffer-name)) (delete-other-windows)))

(defadvice magit-commit-create (before ta-magit-commit-create-advice activate)
  (delete-other-windows))
#+END_SRC

** Custom minor modes

#+BEGIN_SRC emacs-lisp
(defvar i3-font-lock-keywords
  '(("bindsym" . font-lock-keyword-face)
    ("^set" . font-lock-keyword-face)
    ("^mode" . font-lock-keyword-face)
    ("^exec" . font-lock-keyword-face)
    ("^workspace" . font-lock-keyword-face)
    ("^bar" . font-lock-builtin-face)
    ("\\(colors\\) [{]+" 1 font-lock-builtin-face t)
    ("^font" . font-lock-builtin-face)
    ("^floating_modifier" . font-lock-builtin-face)
    ;; for ~/.i3status.conf file
    ("^[ \t]*\\(.+?\\)\\(?:\\[\\(.*?\\)\\]\\)?[ \t]*[^+]="
     1 font-lock-variable-name-face t)
    ("\\(^order\\) \\(?:[+][=]+\\)" 1 font-lock-keyword-face t)
    ("\\(general\\) [{]+" 1 font-lock-builtin-face t)
    ("\\(run_watch VPN\\) [{]+" 1 font-lock-builtin-face t)
    ("\\(run_watch DHCP\\) [{]+" 1 font-lock-builtin-face t)
    ("\\(wireless _first_\\) [{]+" 1 font-lock-builtin-face t)
    ("\\(disk\\) .* [{]+" 1 font-lock-builtin-face t)
    ("\\(load\\) [{]+" 1 font-lock-builtin-face t)
    ("\\(cpu_usage\\) [{]+" 1 font-lock-builtin-face t)
    ("\\(battery 0\\) [{]+" 1 font-lock-builtin-face t)
    ("\\(tztime local\\) [{]+" 1 font-lock-builtin-face t)
    )
  "Font lock keywords to use in i3-conf-mode.

These keywords are used in the i3 configuration file and i3status
configuration.")


(define-derived-mode i3-conf-mode sh-mode "i3-conf"
  "Major mode for i3 configuration files."
  (font-lock-add-keywords nil i3-font-lock-keywords))
#+END_SRC

** emacs-lisp
To write my own ~emacs~ commands, I started using the following
~variables~, ~functions~, ~macros~ and ~special forms~.
*** macros
- ~save-excursion~
*** functions
**** from [[https://github.com/magnars/s.el][s]]
- ~s-contains-p~
**** built-in
- ~buffer-name~
- ~car~
- ~delete-other-windows~
- ~equal~
- ~kill-new~
- ~looking-back~
- ~match-string~
- ~open-line~
- ~search-forward-regexp~
- ~search-forward-regexp~
- ~sgml-beginning-of-tag~
- ~sgml-get-context~
- ~sgml-skip-tag-forward~
- ~symbol-at-point~
- ~symbol-at-point~
- ~symbol-name~
* Step 5 (August 2019 - January 2020)
commit d61293297bd0c77126cb969ea5520775d1c83f7c (v1.0.0).

I used emacs 28.50 (I think).

I gave a [[https://www.youtube.com/watch?v=utrTqWB_ncU][talk]] on /Pypi/ and /docopt/ at [[https://2019.es.pycon.org/][PyConEs2019]] in october 2019
and a [[https://www.youtube.com/watch?v=YDuqSwyZvlY][lightning talk]] on /yasnippet/ at [[https://emacsconf.org/2019/][EmacsConf2019]] in november 2019
emacs.  This made me realize that:
1. I enjoy giving talk,
2. I enjoy producing /emacs/ screencast,
3. *I need to take the time to correctly set up emacs to be a better
   programmer*.

After a few month working on my /emacs/ setup and also on my
[[https://github.com/tonyaldon/settings][linux settings]], I ended up with this versionned emacs setup, now
public on github at [[https://github.com/tonyaldon/emacs.d][tonyaldon/emacs.d]].

I started tweaking commands around /lines/ and /sexps/.  I really
enjoyed the teleportation capability of ~avy~.  I've made /hydras/
for almost everything.  I started learning and using /regexp/.  I
started refactoring code with ~wgrep-mode~ and renaming files with
~wdired-mode~.  It's just amazing.  I started to have a custom setup
of the ~dired-mode~.  I wrote my first /minor-mode/.  I tried to use
and learn ~smartparens~.  But it's a huge package and I was lost in
the cool available commands.  I started defining /filter-groups/ in
~ibuffer~.  I wrote my own /theme/.  I discovered ~key-chord~ power.

** Miscellaneous

#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 100)
(global-set-key [escape] 'kill-this-buffer)
#+END_SRC

** UI
I used my own them ~discreet-theme~:

#+BEGIN_SRC emacs-lisp
(let ((d-black-1       "#151515")
      (d-black-2       "#161a1f")
      (d-black-3       "#222")
      (d-black-4       "#333")
      (d-gray-1        "#555")
      (d-gray-2        "#5e5e5e")
      (d-gray-3        "#8c8c8c")
      (d-gray-4        "#b3b3b3")
      (d-white-0       "#ffffff")
      (d-white-1       "#dedede")
      (d-red           "#ff6c60")
      (d-orange-1      "#fd721f")
      (d-orange-2      "#fd971f")
      (d-yellow-1      "#ffd500") ; not used here (for cursor)
      (d-yellow-2      "#eedc82")
      (d-yellow-3      "#f5ebb6")
      (d-green-1       "#60ff6c")
      (d-green-2       "#26f9ad")
      (d-aquamarine-1  "#7fffd4")
      (d-aquamarine-2  "#359b79")
      (d-aquamarine-3  "#458b74")
      (d-cyan-1        "#457f8b")
      (d-cyan-2        "#5297a5")
      (d-blue-1        "#87cefa")
      (d-blue-2        "#8795fa") ; not used here (for cursor)
      (d-pink-1        "#fa87ce") ; not used here (for cursor)
      (d-pink-2        "#f92672"))

  (custom-theme-set-faces
   'discreet

   `(bold ((t (:bold t))))
   `(default ((t (:background ,d-black-1 :foreground ,d-white-1))))
   `(hl-line ((t (:background ,d-black-4 ))))
   `(cursor ((t (:background ,d-green-2))))
   `(mc/cursor-bar-face ((t (:background ,d-white-1 :height 3))))

   `(highlight ((t (:background ,d-aquamarine-3 :foreground ,d-white-1 :bold t))))
   `(lazy-highlight ((t (:background ,d-gray-3 :foreground ,d-white-1))))
   `(region ((t (:background ,d-gray-2 :foreground ,d-white-1))))

   `(isearch ((t (:inherit highlight))))
   `(isearch-fail ((t (:background ,d-red))))

   `(show-paren-match ((t (:background ,d-black-4 :foreground ,d-white-0 :underline t :weight ultra-bold))))
   `(show-paren-mismatch ((t (:background ,d-red :foreground ,d-white-1 :weight bold))))

   `(avy-lead-face ((t (:foreground ,d-red :weight bold))))
   `(avy-lead-face-0 ((t (:inherit avy-lead-face))))
   `(avy-lead-face-1 ((t (:inherit avy-lead-face))))
   `(aw-leading-char-face ((t (:inherit avy-lead-face))))

   `(minibuffer-prompt ((t (:foreground ,d-aquamarine-1))))

   `(header-line ((t (:background ,d-black-1 :foreground ,d-orange-2 :weight bold))))
   `(ta-dired-header-face ((t (:foreground ,d-black-1))))
   `(dired-directory ((t (:inherit font-lock-function-name-face :weight bold))))
   `(dired-flagged ((t (:inherit error))))
   `(dired-header ((t (:inherit ta-dired-header-face))))
   `(dired-ignored ((t (:inherit shadow))))
   `(dired-mark ((t (:inherit font-lock-variable-name-face))))
   `(dired-marked ((t (:inherit font-lock-variable-name-face))))
   `(dired-perm-write ((t (:inherit font-lock-comment-delimiter-face))))
   `(dired-symlink ((t (:inherit font-lock-keyword-face))))
   `(dired-warning ((t (:inherit font-lock-warning-face))))

   `(mode-line ((t (:background ,d-aquamarine-3 :foreground ,d-black-1))))
   `(mode-line-inactive ((t (:background ,d-gray-1 :foreground ,d-gray-3))))
   `(mode-line-buffer-id ((t (:foreground ,d-gray-4 :weight bold))))
   `(vc-state-base ((t (:foreground ,d-orange-2))))

   `(error ((t (:foreground ,d-red))))
   `(warning ((t (:foreground ,d-orange-1))))
   `(success ((t (:foreground ,d-green-1))))
   `(match ((t (:foreground ,d-orange-2 :weight bold))))

   `(info-xref ((t (:foreground ,d-aquamarine-2 :underline t))))
   `(info-xref-visited ((t (:foreground ,d-yellow-3 :underline t))))
   `(info-header-xref ((t (:foreground ,d-white-1 :underline t))))
   `(info-menu-star ((t (:foreground ,d-white-1))))
   `(link ((t (:foreground ,d-aquamarine-2 :underline t))))

   `(wgrep-done-face ((t (:foreground ,d-blue-1 :weight bold))))
   `(wgrep-face ((t (:underline (:color ,d-gray-4 :style wave)))))
   `(wgrep-file-face ((t (:background ,d-gray-2 :foreground ,d-white-1))))
   `(wgrep-reject-face ((t (:foreground ,d-pink-2 :weight bold))))

   `(compilation-error ((t (:foreground ,d-red))))
   `(compilation-info ((t (:foreground ,d-cyan-2 :underline t))))
   `(compilation-line-number ((t (:foreground ,d-yellow-2 :underline t))))
   `(compilation-warning ((t (:foreground ,d-orange-2))))
   `(compilation-mode-line-exit ((t (:foreground ,d-green-1))))
   `(compilation-mode-line-fail ((t (:foreground ,d-red))))
   `(compilation-mode-line-run ((t (:foreground ,d-orange-2))))

   `(company-preview ((t (:foreground ,d-aquamarine-3 :inherit hl-line :bold t))))
   `(company-preview-common ((t (:foreground ,d-aquamarine-3 :inherit hl-line :bold t))))
   `(company-preview-search ((t (:foreground ,d-orange-2 :inherit hl-line :bold t))))
   `(company-scrollbar-bg ((t (:background ,d-black-4))))
   `(company-scrollbar-fg ((t (:inherit highlight))))
   `(company-tooltip ((t (:foreground ,d-gray-3 :background ,d-black-1))))
   `(company-tooltip-common ((t (:foreground ,d-aquamarine-3 :weight bold))))
   `(company-tooltip-common-selection ((t (:foreground ,d-aquamarine-1 :weight bold))))
   `(company-tooltip-selection ((t (:inherit highlight))))
   `(company-tooltip-annotation ((t (:foreground ,d-orange-2))))
   `(company-tooltip-annotation-selection ((t (:foreground ,d-orange-2))))
   `(company-tooltip-search ((t (:foreground ,d-orange-2 :bold t))))
   `(company-tooltip-search-selection ((t (:foreground ,d-orange-2 :bold t))))

   `(ivy-current-match ((t (:inherit highlight))))
   `(ivy-cursor ((t (:background ,d-white-1))))
   `(ivy-minibuffer-match-face-1 ((t (:background ,d-gray-1 :foreground ,d-white-1))))
   `(ivy-minibuffer-match-face-2 ((t (:inherit lazy-highlight))))
   `(ivy-minibuffer-match-face-3 ((t (:inherit lazy-highlight))))
   `(ivy-minibuffer-match-face-4 ((t (:inherit lazy-highlight))))
   `(ivy-posframe ((t (:background ,d-black-3))))
   `(ivy-posframe-border ((t (:background ,d-aquamarine-2))))
   `(ivy-posframe-cursor ((t (:inherit ivy-cursor))))
   `(ivy-prompt-match ((t (:inherit ivy-current-match))))

   `(swiper-background-match-face-1 ((t (:inherit ivy-minibuffer-match-face-1))))
   `(swiper-background-match-face-2 ((t (:inherit ivy-minibuffer-match-face-2))))
   `(swiper-background-match-face-3 ((t (:inherit ivy-minibuffer-match-face-3))))
   `(swiper-background-match-face-4 ((t (:inherit ivy-minibuffer-match-face-4))))
   `(swiper-isearch-current-match ((t (:background "black" :foreground "white"))))
   `(swiper-line-face ((t (:inherit highlight))))
   `(swiper-match-face-1 ((nil)))
   `(swiper-match-face-2 ((nil)))
   `(swiper-match-face-3 ((nil)))
   `(swiper-match-face-4 ((nil)))

   `(counsel--mark-ring-highlight ((t (:inherit highlight))))
   `(counsel-application-name ((t (:inherit font-lock-builtin-face))))
   `(counsel-key-binding ((t (:inherit font-lock-keyword-face))))

   ;; font-lock
   `(font-lock-negation-char-face ((t (:foreground ,d-red))))
   `(font-lock-warning-face ((t (:foreground ,d-orange-2))))
   `(font-lock-variable-name-face ((t (:foreground ,d-orange-2))))
   `(font-lock-doc-face ((t (:foreground ,d-yellow-2))))
   `(font-lock-doc-string-face ((t (:foreground ,d-yellow-2))))
   `(font-lock-string-face ((t (:foreground ,d-yellow-2))))
   `(font-lock-function-name-face ((t (:foreground ,d-aquamarine-3))))
   `(font-lock-builtin-face ((t (:foreground ,d-cyan-1))))
   `(font-lock-type-face ((t (:foreground ,d-cyan-2))))
   `(font-lock-keyword-face ((t (:foreground ,d-pink-2))))
   `(font-lock-preprocessor-face ((t (:foreground ,d-pink-2))))
   `(font-lock-comment-delimiter-face ((t (:foreground ,d-gray-3))))
   `(font-lock-comment-face ((t (:foreground ,d-gray-3))))
   `(font-lock-constant-face ((t (:foreground ,d-yellow-3))))
   `(font-lock-reference-face ((t (:foreground ,d-yellow-3))))
   `(font-lock-regexp-grouping-backslash ((t (:foreground ,d-blue-1))))
   `(font-lock-regexp-grouping-construct ((t (:foreground ,d-blue-1))))
   `(font-lock-number-face ((t (:foreground ,d-yellow-2))))))
#+END_SRC

** dired-mode

#+BEGIN_SRC emacs-lisp
(require 'dash)
(require 'dired)
(require 'dired-details)
(require 'dired-hacks-utils)
(require 'dired-hide-dotfiles)
(require 'dired-narrow)
(require 'dired-open)
(require 'dired-subtree)
(require 's)

(setq dired-dwim-target t)
(setq dired-recursive-copies 'always)
(setq-default dired-details-hidden-string "")
(setq-default dired-listing-switches "-lhA --group-directories-first")
(setq dired-open-extensions
      '(("pdf" . "evince")
        ("jpg" . "eog")
        ("png" . "eog")))
(setq-default dired-subtree-line-prefix "  ")
(setq-default dired-subtree-use-backgrounds nil)

(dired-details-install)
(dired-hide-dotfiles-mode)

(defun ta-size-bigger-file-or-directory-in-dired ()
  "Return the number of characters of the bigger FILE-OR-DIRECTORY in current dired buffer."
  (with-current-buffer (current-buffer)
    (-max (--map (length (-last-item (s-split "/" it)))
                 (dired-utils-get-all-files)))))

(defun ta-dired-current-buffer-file-toggle ()
  "Pop a buffer on the left of the frame in `dired-mode'

with the parent directory of the current `buffer-file-name' if not `nil' and
if the frame contains any buffer in `dired-mode'. If the frame contains buffers
in `dired-mode', delete them.
"
  (interactive)
  ;; TODO: - check the case of buffer-file-name is nil
  ;; TODO: - check the case of the is only one buffer in dired-mode
  (setq current-window (car (avy-window-list)))
  (setq window-list (avy-window-list))
  (setq dired-buffer-into-frame-p nil)
  (while window-list
    (select-window (car window-list))
    (if (string-equal major-mode "dired-mode")
        (progn
          (setq dired-buffer-into-frame-p t)
          (delete-window)))
    (setq window-list (cdr window-list)))
  (if dired-buffer-into-frame-p
      nil
    (select-window current-window)
    (delete-other-windows)
    (let ((width (with-current-buffer
                     (dired-noselect (file-name-directory (buffer-file-name)))
                   (ta-size-bigger-file-or-directory-in-dired))))
      (split-window-right (+ 10 width))) ; 10 is arbitrary
    (dired (file-name-directory (buffer-file-name)))))

(define-minor-mode dired-header-line-mode
  "Show only the last two directories of the path to the current
directory that `dired-mode' is displaying."
  :init-value nil :group 'header-line :group 'dired
  (unless (derived-mode-p 'dired-mode)
    (error "You must be in dired-mode to use this command"))
  (if dired-header-line-mode
      (progn
        (setq path-len
              (length (s-split "/" (expand-file-name dired-directory))))
        (setq header-line-directories
              (car (last
                    (s-split-up-to "/"
                                   (expand-file-name dired-directory)
                                   (- path-len 3)))))
        (setq header-line-format (concat "..." header-line-directories)))
    (setq header-line-format  (default-value 'header-line-format))))

(defface ta-dired-header-face
  nil
  "Face for dired header, first line of buffer in `dired-mode'"
  :group 'dired)

(font-lock-add-keywords
 'dired-mode
 '(("\\(^.*:$\\)" . 'ta-dired-header-face)))

(font-lock-add-keywords
 'wdired-mode
 '(("\\(^.*:$\\)" . 'ta-dired-header-face)))

(add-hook 'dired-mode-hook (lambda () (dired-hide-details-mode 1)))
(add-hook 'dired-before-readin-hook 'dired-header-line-mode)

#+END_SRC
** hydra
*** hydra settings

#+BEGIN_SRC emacs-lisp
(setq-default hydra-hint-display-type  'message)
#+END_SRC

*** kmacro

#+BEGIN_SRC emacs-lisp
(defhydra hydra-kmacro
  (:pre (hydra-color-pre)
   :post (hydra-color-post)
   :hint nil)
  ("<next>" hydra-lines/body :color blue)
  ("<prior>" hydra-sp-reshape/body :color blue)
  ("." hydra-sp/body :color blue)
  ("s" kmacro-set-counter :color blue)
  ("r" kmacro-insert-counter)
  ("l" kmacro-end-or-call-macro)
  ("<up>" kmacro-cycle-ring-previous :color blue)
  ("<down>" kmacro-cycle-ring-next :color blue)
  ("n" kmacro-name-last-macro :color blue)
  ("b" kmacro-bind-to-key :color blue)
  ("e" kmacro-edit-macro :color blue)
  ("M--" undo)
  ("q" nil))
#+END_SRC

*** lines

#+BEGIN_SRC emacs-lisp
(defhydra hydra-lines
  (:pre (hydra-color-pre-lines)
   :post (progn (hydra-color-post) (hydra-lines-active))
   :hint nil)
  ("<prior>" hydra-sp-reshape/body :color blue)
  ("." hydra-sp/body :color blue)
  ("j" hydra-org/body :color blue)
  ("m" hydra-scrolling/body :color blue)
  ;; ---
  (";" ta-comment-line)
  ("DEL" delete-backward-char)
  (">" set-mark-command)
  ("t" exchange-point-and-mark)
  ;; action on line(s)
  (":" ta-avy-mark-region)
  ("c" avy-copy-line)
  ("@" avy-kill-whole-line)
  ("C" avy-copy-region)
  ("%" avy-kill-region)
  ("!" flush-lines)
  ("?" keep-lines)
  ;; current line
  ("/" ta-mark-current-line)
  ("k" kill-line)
  ("l" (kill-line 0))
  ("x" ta-kill-whole-line)
  ("w" ta-kill-ring-save-current-line :color blue)
  ("y" ta-copy-current-line-yank-below)
  ("r" join-line)
  ("o" open-line)
  ("'" delete-blank-lines)
  ("," delete-horizontal-space)
  ;; to insert text
  ("u" ta-above-new-indent :color blue)
  ("]" ta-below-new-indent :color blue)
  ("_" ta-add-space :color blue)
  ;; quick motions
  ("n" next-logical-line)
  ("p" previous-logical-line)
  ("f" forward-char)
  ("b" backward-char)
  ("M-f" forward-word)
  ("M-b" backward-word)
  ("M-e" forward-paragraph)
  ("M-a" backward-paragraph)
  ("i" back-to-indentation)
  ("a" move-beginning-of-line)
  ("e" move-end-of-line)
  ;; drag stuff
  ("d" drag-stuff-up)
  ("s" drag-stuff-down)
  ;; clean/undo/nil
  ("g" cleanup-buffer)
  ("M--" undo)
  ("q" nil))
#+END_SRC

*** org-mode
At that time, I didn't know about ~org-speed-commands~.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org
  (:pre (hydra-color-pre-org)
   :post (hydra-color-post)
   :hint nil)
  ("<prior>" hydra-sp-reshape/body :color blue)
  ("<next>" hydra-lines/body :color blue)
  ("." hydra-sp/body :color blue)
  ("j" hydra-org/body :color blue)
  ("m" hydra-scrolling/body :color blue)
  ;; ---
  ("M-l" org-mark-ring-goto)
  ("c" org-copy-subtree)
  ("k" org-kill-line)
  ("p" outline-previous-visible-heading)
  ("n" outline-next-visible-heading)
  ("b" org-backward-heading-same-level)
  ("f" org-forward-heading-same-level)
  ("Y" outline-up-heading)
  ("u" org-down-element)
  ("y" org-up-element)
  ;; ("c RET" org-insert-heading-after-current)
  ("RET" org-meta-return :color blue)
  ("i" org-ctrl-c-minus)
  ("*" org-ctrl-c-star)
  (">" org-metaright)
  ("<" org-metaleft)
  (")" org-shiftmetaright)
  ("(" org-shiftmetaleft)
  ("<up>" org-shiftmetaup)
  ("<down>" org-shiftmetadown)
  ("d" org-shiftup)
  ("s" org-shiftdown)
  ("^" org-sort)
  ("[" org-narrow-to-subtree)
  ("]" widen)
  ("<tab>" org-cycle)
  ("o" org-open-at-point)
  ("q" nil))
#+END_SRC

*** scrolling

#+BEGIN_SRC emacs-lisp
(defhydra hydra-scrolling
  (:pre (hydra-color-pre-scrolling)
   :post (hydra-color-post)
   :hint nil)
  ("<prior>" hydra-sp-reshape/body :color blue)
  ("<next>" hydra-lines/body :color blue)
  ("." hydra-sp/body :color blue)
  ("j" hydra-org/body :color blue)
  ;; ---
  ("<" beginning-of-buffer)
  (">" end-of-buffer)
  ("<backspace>" scroll-down-command)
  ("SPC" scroll-up-command)
  ("p" ta-scroll-down-line)
  ("n" ta-scroll-up-line)
  ("f" scroll-left)
  ("b" scroll-right)
  ;; ---
  ("u" recenter-top-bottom)
  ("a" move-to-window-line-top-bottom)
  ;; ---
  ("e" scroll-other-window)
  ("i" scroll-other-window-down)
  ("o" ta-scroll-other-window-line)
  ("x" ta-scroll-other-window-down-line)
  ("q" nil))
#+END_SRC

*** smartparens

#+BEGIN_SRC emacs-lisp
(defhydra hydra-sp
  (:pre (hydra-color-pre-sp)
   :post (hydra-color-post)
   :hint nil)
  ("<prior>" hydra-sp-reshape/body :color blue)
  ("<next>" hydra-lines/body :color blue)
  ("j" hydra-org/body :color blue)
  ("m" hydra-scrolling/body :color blue)
  ;; ---
  ("S" smartparens-global-strict-mode :color blue)
  ;; ---
  ("}" set-mark-command)
  ("t" exchange-point-and-mark)
  ("r" join-line)
  ;; ---
  ("k" sp-kill-whole-line)
  ("," sp-kill-sexp)
  ("DEL" sp-backward-kill-sexp)
  ("c" sp-copy-sexp)
  ("@" sp-backward-copy-sexp)
  (";" sp-comment)
  ("N" sp-narrow-to-sexp)
  ;; sp-motion
  (">" sp-beginning-of-next-sexp)
  ("<" sp-beginning-of-previous-sexp)
  ("f" sp-forward-sexp)
  ("b" sp-backward-sexp)
  ("n" sp-next-sexp)
  ("p" sp-previous-sexp)
  ("u" sp-down-sexp)
  ("i" sp-up-sexp)
  ("y" sp-backward-up-sexp)
  ("x" sp-backward-down-sexp)
  ("a" sp-beginning-of-sexp)
  ("e" sp-end-of-sexp)
  ;; to insert text
  ("_" ta-add-space :color blue)
  ;; ---
  ("$" sp-show-enclosing-pair)
  ("{" sp-wrap-curly)
  ("(" sp-wrap-round)
  ("[" sp-wrap-square)
  ("/" sp-rewrap-sexp)
  ("s" sp-swap-enclosing-sexp)
  ;; ---
  ("g" cleanup-buffer)
  ("M--" undo)
  ("q" nil))

(defhydra hydra-sp-reshape
  (:pre (hydra-color-pre-sp-reshape)
   :post (hydra-color-post)
   :hint nil)
  ("<next>" hydra-lines/body :color blue)
  ("." hydra-sp/body :color blue)
  ("j" hydra-org/body :color blue)
  ("m" hydra-scrolling/body :color blue)
  ;; ---
  ("k" sp-kill-whole-line)
  ("," sp-kill-sexp)
  ("DEL" sp-backward-kill-sexp)
  ("c" ta-avy-copy-sexp :color blue)
  ("@" ta-avy-kill-sexp :color blue)
  (";" sp-comment)
  ("N" sp-narrow-to-sexp)
  ;; ---
  ("a" sp-absorb-sexp)
  ("i" sp-change-inner :color blue)
  ("/" sp-change-enclosing :color blue)
  ("e" sp-emit-sexp)
  ;; ---
  ("%" sp-convolute-sexp)
  ;; ---
  ("d" ta-drag-sexp-to-left)
  ("s" ta-drag-sexp-to-right)
  ;; ---
  ("f" sp-forward-slurp-sexp)
  ("b" sp-backward-slurp-sexp)
  (")" sp-forward-barf-sexp)
  ("(" sp-backward-barf-sexp)
  ("p" sp-add-to-previous-sexp)
  ("n" sp-add-to-next-sexp)
  ;; ---
  (":" sp-split-sexp)
  ("'" sp-join-sexp)
  ;; ---
  ("[" sp-splice-sexp-killing-backward)
  ("]" sp-splice-sexp-killing-forward)
  ("u" sp-splice-sexp :color blue)
  ("r" sp-raise-sexp)
  ;; ---
  ("g" cleanup-buffer)
  ("M--" undo)
  ("q" nil))
#+END_SRC

*** toggle write mode

#+BEGIN_SRC emacs-lisp
(defhydra hydra-toggle
  (:pre (hydra-color-pre)
   :post (hydra-color-post)
   :hint nil)
  ("n" ta-toggle-write-mode :color blue)
  ("i" ta-w-abort-changes :color blue)
  ("e" ta-w-exit :color blue)
  ("f" ta-w-finish-edit :color blue)
  ("M--" undo)
  ("q" nil))
#+END_SRC

** External cli
- I used [[https://github.com/flycheck/flycheck][flycheck]] with [[https://www.pylint.org/][pylint]] cli for python syntax checking.
- I used [[https://github.com/company-mode/company-mode][company-mode]] with [[https://github.com/ternjs/tern][tern]] cli javascript analyzer.
** Discarded Packages (in the setup)
I replaced [[https://github.com/winterTTr/ace-jump-mode][ace-jump-mode]] by [[https://github.com/abo-abo/avy][avy]] (I think it was to be consistent with
[[https://github.com/abo-abo/ace-window][ace-window]]).  I replace ~shell~ by ~term~.

| packages/modes  | links         |
|-----------------+---------------|
| ~shell~         | built-in      |
| ~ace-jump-mode~ | [[https://github.com/winterTTr/ace-jump-mode][ace-jump-mode]] |

** New Packages (in the setup)
| packages/modes            | links          |
|---------------------------+----------------|
| ~eldoc-mode~              | built-in       |
| ~term~                    | built-in       |
| ~save-place-mode~         | built-in       |
| ~global-auto-revert-mode~ | built-in       |
| ~eterm-256color~          | [[https://github.com/dieggsy/eterm-256color][eterm-256color]] |
| ~minimap~                 | [[https://github.com/dengste/minimap][minimap]]        |
| ~wgrep~                   | [[https://github.com/mhayashi1120/Emacs-wgrep][wgrep]]          |
| ~moody~                   | [[https://github.com/tarsius/moody][moody]]          |
| ~minions~                 | [[https://github.com/tarsius/minions][minions]]        |
| ~company-tern~            | [[https://github.com/kevinushey/company-tern][company-tern]]   |
| ~anaconda-mode~           | [[https://github.com/pythonic-emacs/anaconda-mode][anaconda-mode]]  |
| ~flycheck~                | [[https://github.com/flycheck/flycheck][flycheck]]       |
| ~ivy-posframe~            | [[https://github.com/tumashu/ivy-posframe][ivy-posframe]]   |
| ~key-chord~               | [[https://github.com/emacsorphanage/key-chord][key-chord]]      |
| ~drag-stuff~              | [[https://github.com/rejeep/drag-stuff.el][drag-stuff]]     |
** New commands (in the setup)
| commands              | packages |
|-----------------------+----------|
| ert                   | built-in |
| eval-defun            | built-in |
| eval-last-sexp        | built-in |
| kill-this-buffer      | built-in |
| narrow-to-defun       | built-in |
| narrow-to-region      | built-in |
| next-buffer           | built-in |
| previous-buffer       | built-in |
| rgrep                 | built-in |
| widen                 | built-in |
| avy-goto-line         | [[https://github.com/abo-abo/avy][avy]]      |
| avy-goto-word-1       | [[https://github.com/abo-abo/avy][avy]]      |
| ivy-occur             | [[https://github.com/abo-abo/swiper][ivy]]      |
| swiper-thing-at-point | [[https://github.com/abo-abo/swiper][ivy]]      |
** Custom commands
*** Marking things

#+BEGIN_SRC emacs-lisp
(defun ta-pop-local-mark-ring ()
  (interactive)
  (set-mark-command t))

(defun ta--point-at-beginnig-sp-sexp-p ()
  "Return non-nil if `point' is at the beginning of a sp-sexp

and :op non empty. See `sp-get-thing'."
  (let ((ok (sp-get-thing)))
    (when ok
      (when (and (eq (point) (sp-get ok :beg))
                 (not (string-empty-p (sp-get ok :op))))
        (point)))))

(defun ta--mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun ta-mark-sexp-at-point ()
  "Mark the `sexp' at point. See `sexp-at-point' and `sp-mark-sexp'."
  (interactive)
  (if (or (ta--point-at-beginnig-sp-sexp-p)
          (eq (following-char) ?<))
      (sp-mark-sexp)
    (if (eq (preceding-char) ?\")
        (progn
          (sp-backward-sexp)
          (sp-mark-sexp))
      (if (and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
               (looking-back "[[:alnum:]]" 1))
          (backward-char 1))
      (ta--mark-sexp-at-point))))

(defun ta-point-in-string-p (pt)
  "Returns t if PT is in a string"
  (eq 'string (syntax-ppss-context (syntax-ppss pt))))

(defun ta-goto-begining-of-string (pt)
  "Go to begining of the string if PT is inside a string.
Return nil if PT isn't inside a string. See the function `ta-point-in-string-p'"
  (if (ta-point-in-string-p pt)
      (goto-char (nth 8 (syntax-ppss pt)))
    nil))

(defun ta-mark-inside-pairs ()
  "An other way to do `er/mark-inside-pairs' but work for sgml-tag too."
  (interactive)
  (ta-goto-begining-of-string (point))
  (sp-backward-up-sexp)
  (sp-mark-sexp)
  (sp-down-sexp)
  (exchange-point-and-mark)
  (sp-backward-down-sexp)
  (exchange-point-and-mark))
#+END_SRC

*** Miscellaneous

#+BEGIN_SRC emacs-lisp
(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting.

see: http://github.com/magnars"
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(defun ta-number-lines-whole-buffer ()
  "Number of lines in the whole buffer.
Printed in the message area"
  (interactive)
  (message "Buffer's number of lines: %s"
           (int-to-string (count-lines (point-min) (point-max)))))

(defun ta-unfill-paragraph ()
  "Transform a paragraph into a single line."
  (interactive)
  (let ((fill-column (point-max)))
    (fill-paragraph nil t)))
#+END_SRC

*** Operation related to lines

#+BEGIN_SRC emacs-lisp
(defun ta-mark-current-line ()
  "Mark the current line."
  (interactive)
  (end-of-line)
  (set-mark (point))
  (beginning-of-line))

(defun ta-copy-current-line-yank-below ()
  "copy current line and yank it to the next line.
Cursor doesn't move."
  (interactive)
  (setq init-point (point))
  (save-excursion
    (beginning-of-line)
    (setq beg-point (point))
    (end-of-line)
    (setq end-point (point))
    (setq line-text (delete-and-extract-region end-point beg-point))
    (insert line-text)
    (newline)
    (insert line-text))
  (goto-char init-point))

(defun ta-kill-ring-save-current-line ()
  "Save the current line as if killed, but don't kill it."
  (interactive)
  (setq init-point (point))
  (save-excursion
    (beginning-of-line)
    (setq beg-point (point))
    (end-of-line)
    (setq end-point (point))
    (copy-region-as-kill beg-point end-point))
  (goto-char init-point))

(defun ta-comment-line ()
  (interactive)
  (save-excursion
    (beginning-of-line)
    (let ((beg (point)))
      (end-of-line)
      (setq end (point))
      (comment-or-uncomment-region beg end))))

(defun ta-above-new-indent ()
  "In the current line, back to indent then split line as `split-line'"
  (interactive)
  (back-to-indentation)
  (split-line))

(defun ta-below-new-indent ()
  "Do `end-of-visual-line' then `newline-and-indent'"
  (interactive)
  (end-of-line)
  (newline-and-indent))

(defun ta-add-space ()
  "Add space at point without moving."
  (interactive)
  (insert " ")
  (goto-char (- (point) 1)))

(defun ta-avy-mark-region (arg)
  "Select two lines and mark the region between them"
  (interactive "P")
  (avy-with avy-kill-ring-save-region
    (let* ((beg (save-selected-window
                  (list (avy--line arg) (selected-window))))
           (end (list (avy--line arg) (selected-window))))
      (cond
       ((not (numberp (car beg)))
        (user-error "Fail to select the beginning of region"))
       ((not (numberp (car end)))
        (user-error "Fail to select the end of region"))
       ((not (equal (cdr beg) (cdr end)))
        (user-error "Selected points are not in the same window"))
       ((< (car beg) (car end))
        (set-mark (car beg))
        (goto-char (car end))
        (end-of-line))
       (t
        (set-mark (car beg))
        (goto-char (car end))
        (exchange-point-and-mark)
        (end-of-line))))))

(defun ta-kill-whole-line ()
  "Kill the whole current line.

Preserve the column position of the cursor."
  (interactive)
  (let ((column-position (current-column)))
    (kill-whole-line)
    (move-to-column column-position)))
#+END_SRC

*** Operation related to sexp

#+BEGIN_SRC emacs-lisp
(defun ta-drag-sexp-to-left ()
  "Drag next sexp to the left of the previous sexp.

Work as I want with `sp-navigate-interactive-always-progress-point'
set to non-nil value."
  (interactive)
  (sp-forward-sexp)
  (sp-backward-sexp)
  (sp-transpose-sexp)
  (sp-backward-sexp 2))

(defun ta-drag-sexp-to-right ()
  "Drag next sexp to the left of the previous sexp.

Work as I want with `sp-navigate-interactive-always-progress-point'
set to non-nil value."
  (interactive)
  (sp-forward-sexp)
  (sp-transpose-sexp)
  (sp-backward-sexp))

(defun ta-avy-copy-sexp ()
  "Copy a selected sexp at the current point"
  (interactive)
  (let ((initial-window (selected-window)))
    (save-excursion
      (call-interactively 'avy-goto-char)
      (sp-copy-sexp))
    (select-window initial-window)
    (yank)))

(defun ta-avy-kill-sexp ()
  "Kill a selected sexp and save it in the kill ring"
  (interactive)
  (let ((initial-window (selected-window)))
    (save-excursion
      (call-interactively 'avy-goto-char)
      (sp-kill-sexp))
    (select-window initial-window)))
#+END_SRC

*** Scrolling

#+BEGIN_SRC emacs-lisp
(defun ta-scroll-down-line ()
  "Scroll down of one line"
  (interactive)
  (scroll-up-line -1))

(defun ta-scroll-up-line ()
  "Scroll up of one line"
  (interactive)
  (scroll-up-line))

(defun ta-scroll-other-window-line ()
  "Scroll up of one line in other window. See `scroll-other-window'"
  (interactive)
  (scroll-other-window 1))

(defun ta-scroll-other-window-down-line ()
  "Scroll up of one line in other window. See `scroll-other-window'"
  (interactive)
  (scroll-other-window-down 1))
#+END_SRC

*** Windows

#+BEGIN_SRC emacs-lisp
(defun ta-drag-window-left ()
  "Drag current window one window to the left."
  (interactive)
  (aw-swap-window (window-in-direction 'left)))

(defun ta-drag-window-right ()
  "Drag current window one window to the right."
  (interactive)
  (aw-swap-window (window-in-direction 'right)))

(defun ta-drag-window-above ()
  "Drag current window one window to the above."
  (interactive)
  (aw-swap-window (window-in-direction 'above)))

(defun ta-drag-window-below ()
  "Drag current window one window to the below."
  (interactive)
  (aw-swap-window (window-in-direction 'below)))

(defun ta-split-window-right ()
  "Chain `split-window-right' and `windmove-right'."
  (interactive)
  (split-window-right)
  (windmove-right))

(defun ta-split-window-down ()
  "Chain `split-window-below' and `windmove-down'."
  (interactive)
  (split-window-below)
  (windmove-down))
#+END_SRC

*** Toggle Write mode

#+BEGIN_SRC emacs-lisp
(defun ta-toggle-write-mode ()
  "Toggle to the Writable variant of the current mode.

Call command `dired-toggle-read-only' if `major-mode' is equal
`dired-mode' and call command `wgrep-change-to-wgrep-mode' if
`major-mode' is equal to `grep-mode'."
  (interactive)
  (cond ((string-equal major-mode "dired-mode")
         (call-interactively 'dired-toggle-read-only))
        ((memq major-mode '(grep-mode ivy-occur-grep-mode))
         (call-interactively 'wgrep-change-to-wgrep-mode))
        (t (message "You have to be in either in `dired-mode' or
`grep-mode' to execute this command"))))

(defun ta-w-abort-changes ()
  "Abort changes and return to the appropiate mode.

Call command `wdired-abort-changes' if `major-mode' is
`wdired-mode' and call command `wgrep-abort-changes' if
`major-mode' is `grep-mode'."
  (interactive)
  (cond ((string-equal major-mode "wdired-mode")
         (call-interactively 'wdired-abort-changes))
        ((memq major-mode '(grep-mode ivy-occur-grep-mode))
         (call-interactively 'wgrep-abort-changes))
        (t (message "You have to be in either in `wdired-mode' or
`grep-mode' to execute this command"))))

(defun ta-w-exit ()
  "Exit writable mode and return to the appropiate mode.

Call command `wdired-exit' if `major-mode' is
`wdired-mode' and call command `wgrep-exit' if
`major-mode' is `grep-mode'."
  (interactive)
  (cond ((string-equal major-mode "wdired-mode")
         (call-interactively 'wdired-exit))
        ((memq major-mode '(grep-mode ivy-occur-grep-mode))
         (call-interactively 'wgrep-exit))
        (t (message "You have to be in either in `wdired-mode' or
`grep-mode' to execute this command"))))

(defun ta-w-finish-edit ()
  "Abort changes and return to the appropiate mode.

Call command `wdired-finish-edit' if `major-mode' is
`wdired-mode' and call command `wgrep-finish-edit' if
`major-mode' is `grep-mode'."
  (interactive)
  (cond ((string-equal major-mode "wdired-mode")
         (call-interactively 'wdired-finish-edit))
        ((memq major-mode '(grep-mode ivy-occur-grep-mode))
         (call-interactively 'wgrep-finish-edit))
        (t (message "You have to be in either in `wdired-mode' or
`grep-mode' to execute this command"))))

(defhydra hydra-toggle
  (:pre (hydra-color-pre)
   :post (hydra-color-post)
   :hint nil)
  ("n" ta-toggle-write-mode :color blue)
  ("i" ta-w-abort-changes :color blue)
  ("e" ta-w-exit :color blue)
  ("f" ta-w-finish-edit :color blue)
  ;; ---
  ("M--" undo)
  ("q" nil))
#+END_SRC

** advices

#+BEGIN_SRC emacs-lisp
(defadvice back-to-indentation (before back-to-indentation-advice activate)
  (if (not mark-active) (push-mark)))

(defadvice move-beginning-of-line (before move-beginning-of-line-advice activate)
  (if (not mark-active) (push-mark)))

(defadvice move-end-of-line (before move-end-of-line-advice activate)
  (if (not mark-active) (push-mark)))

(defadvice hydra-lines/body (before hydra-lines-advice activate)
  (hydra-lines-active))

(defadvice ta-avy-mark-region (after ta-avy-mark-region-advice activate)
  (if hydra-lines-active nil
    (hydra-lines/body)))
#+END_SRC

** Custom minor modes

#+BEGIN_SRC emacs-lisp
(define-minor-mode dired-header-line-mode
  "Show only the last two directories of the path to the current
directory that `dired-mode' is displaying."
  :init-value nil :group 'header-line :group 'dired
  (unless (derived-mode-p 'dired-mode)
    (error "You must be in dired-mode to use this command"))
  (if dired-header-line-mode
      (progn
        (setq path-len
              (length (s-split "/" (expand-file-name dired-directory))))
        (setq header-line-directories
              (car (last
                    (s-split-up-to "/"
                                   (expand-file-name dired-directory)
                                   (- path-len 3)))))
        (setq header-line-format (concat "..." header-line-directories)))
    (setq header-line-format  (default-value 'header-line-format))))
#+END_SRC

** emacs-lisp
To write my own ~emacs~ commands, I started using the following
~variables~, ~functions~, ~macros~ and ~special forms~.
*** variables
- ~fill-column~
- ~major-mode~
- ~mark-active~
- ~this-command~
*** special forms
- ~and~
- ~if~
- ~let*~
- ~or~
- ~progn~
- ~save-excursion~
- ~while~
*** macros
- ~defadvice~
- ~defface~
- ~lambda~
- ~save-selected-window~
- ~unless~
- ~with-current-buffer~
*** functions
**** from [[https://github.com/abo-abo/ace-window][ace-window]]
- ~aw-swap-window~
**** from [[https://github.com/abo-abo/avy][avy]]
- ~avy-kill-ring-save-region~
- ~avy-window-list~
- ~avy-with~
**** from [[https://github.com/magnars/dash.el][dash]]
- ~--map~
- ~-last-item~
- ~-max~
**** from [[https://github.com/Fuco1/dired-hacks#dired-hacks-utils][dired-hacks-utils]]
- ~dired-utils-get-all-files~
**** from [[https://github.com/magnars/s.el][s]]
- ~s-capitalize~
- ~s-collapse-whitespace~
- ~s-concat~
- ~s-dashed-words~
- ~s-downcase~
- ~s-lower-camel-case~
- ~s-snake-case~
- ~s-split~
- ~s-split~
- ~s-titleize~
- ~s-titleize~
- ~s-upcase~
- ~s-upper-camel-case~
- ~s-wrap~
**** from [[https://github.com/Fuco1/smartparens][smartparens]]
- ~sp-backward-down-sexp~
- ~sp-backward-sexp~
- ~sp-backward-up-sexp~
- ~sp-down-sexp~
- ~sp-get-thing~
- ~sp-mark-sexp~
- ~sp-mark-sexp~
- ~sp-mark-sexp~
**** built-in
- ~adaptive-wrap-prefix-mode~
- ~add-hook~
- ~add-to-list~
- ~back-to-indentation~
- ~backward-char~
- ~beginning-of-line~
- ~beginning-of-thing~
- ~boundp~
- ~buffer-file-name~
- ~buffer-name~
- ~buffer-substring~
- ~call-interactively~
- ~comment-or-uncomment-region~
- ~copy-region-as-kill~
- ~count-lines~
- ~current-buffer~
- ~current-column~
- ~deactivate-mark~
- ~delete-and-extract-region~
- ~delete-region~
- ~delete-trailing-whitespace~
- ~describe-function~
- ~describe-variable~
- ~dired-noselect~
- ~end-of-thing~
- ~enlarge-window-horizontally~
- ~eq~
- ~exchange-point-and-mark~
- ~fboundp~
- ~file-exists-p~
- ~file-name-nondirectory~
- ~fill-paragraph~
- ~following-char~
- ~font-lock-add-keywords~
- ~get-buffer~
- ~goto-char~
- ~indent-region~
- ~insert~
- ~int-to-string~
- ~kill-whole-line~
- ~length~
- ~looking-back~
- ~make-local-variable~
- ~make-variable-buffer-local~
- ~memq~
- ~move-to-column~
- ~newline~
- ~newline-and-indent~
- ~nth~
- ~numberp~
- ~org-cycle-internal-global~
- ~plist-get~
- ~point~
- ~preceding-char~
- ~push-mark~
- ~re-search-backward~
- ~re-search-forward~
- ~read-file-name~
- ~read-string~
- ~rename-buffer~
- ~rename-file~
- ~scroll-other-window~
- ~scroll-other-window-down~
- ~scroll-up-line~
- ~scroll-up-line~
- ~select-window~
- ~selected-window~
- ~set~
- ~set-buffer-modified-p~
- ~set-mark~
- ~set-visited-file-name~
- ~split-line~
- ~string-empty-p~
- ~string-equal~
- ~symbol-at-point~
- ~syntax-ppss~
- ~syntax-ppss-context~
- ~untabify~
- ~use-region-p~
- ~window-in-direction~
* Step 4 (Jun 2019)
commit 17f3a62a100eaa3b99938248d942007651038b76 (private repository).

I switched my general completion framework from ~ido~ to ~ivy~.  I
discoverd the ~windmove~ built-in package.

** Miscellaneous

#+BEGIN_SRC emacs-lisp
(winner-mode t)
#+END_SRC

** Completion framework
I used [[https://github.com/abo-abo/swiper][ivy]] as general completion framework and [[https://github.com/company-mode/company-mode][company-mode]] as code
completion.
** hydra
I had an hydra command to deal with windows and another to deal with
multiple-cursors.

*** windows

#+BEGIN_SRC emacs-lisp
(defhydra hydra-window-size ()
  ("b" shrink-window-horizontally "shrink h")
  ("f" enlarge-window-horizontally "enlarge h")
  ("p" enlarge-window "shrink v")
  ("n" shrink-window "enlarge v")
  ("q" nil))

(defhydra hydra-window (:color red)
  "window"
  ("c" ta/modify-ui-writing-code "code")
  ("s" ta/modify-ui-shell-window-below "shell")
  ("b" windmove-left)
  ("f" windmove-right)
  ("p" windmove-up)
  ("n" windmove-down)
  ("r" (lambda ()
         (interactive) (split-window-right) (windmove-right)) "right")
  ("d" (lambda ()
         (interactive) (split-window-below) (windmove-down)) "down")
  ("t" transpose-frame "'" :exit t)
  ("o" delete-other-windows "one" :exit t)
  ("TAB" ace-window "ace")
  ("." ace-delete-window "del")
  ("(" ido-switch-buffer "buf")
  (")" ido-find-files "file")
  ("q" nil "cancel")
  ("u" (progn (winner-undo) (setq this-command 'winner-undo)) "undo")
  ("x" make-frame)
  ("w" hydra-window-size/body :color blue)
  ("i" text-scale-adjust :color blue))
#+END_SRC

*** multiple-cursors

#+BEGIN_SRC emacs-lisp
(defhydra hydra-mutiple-cursors ()
  ("p" mc/mark-previous-like-this)
  ("n" mc/mark-next-like-this)
  ("b" mc/mark-previous-like-this-word)
  ("f" mc/mark-next-like-this-word)
  ("mouse-1" mc/add-cursor-on-click)
  ("t" mc/mark-sgml-tag-pair)
  ("q" nil "quit"))
#+END_SRC

** Discarded Packages (in the setup)
I replaced ~ido~ by [[https://github.com/abo-abo/swiper][ivy]] (I wanted vertical layout for completion).

| packages/modes | links    |
|----------------+----------|
| ~ido~          | built-in |
** New Packages (in the setup)
| packages/modes    | links           |
|-------------------+-----------------|
| ~windmove~        | built-in        |
| ~winner-mode~     | built-in        |
| ~transpose-frame~ | [[https://github.com/emacsorphanage/transpose-frame][transpose-frame]] |
** New commands (in the setup)
| commands                 | packages         |
|--------------------------+------------------|
| ~windmove-left~          | built-in         |
| ~windmove-right~         | built-in         |
| ~windmove-up~            | built-in         |
| ~windmove-down~          | built-in         |
| ~emmet-expand-line~      | [[https://github.com/smihica/emmet-mode][emmet-mode]]       |
| ~emmet-prev-edit-point~  | [[https://github.com/smihica/emmet-mode][emmet-mode]]       |
| ~emmet-next-edit-point~  | [[https://github.com/smihica/emmet-mode][emmet-mode]]       |
| ~swiper~                 | [[https://github.com/abo-abo/swiper][swiper]]           |
| ~mc/add-cursor-on-click~ | [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]] |
| ~er/mark-inside-pairs~   | [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]] |
| ~er/mark-inside-quotes~  | [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]] |
** emacs-lisp
To write my own ~emacs~ commands, I started using the following
~variables~, ~functions~, ~macros~ and ~special forms~.
*** special forms
- ~progn~
*** functions
- ~define-key~
- ~eval-after-load~
- ~global-set-key~
- ~kbd~
* Step 3 (April 2019 - May 2019)
commit f620c12e73629412dfa06623b5b9c318515bc9b8 (private repository).

I used ~emacs 24.5~.

So far I've been using default bindings for almost any commands and
speficically for movements ~C-b~, ~C-f~, ~C-p~, ~C-n~, ~C-a~, ~C-e~.
But at this moment, it started *hurting me*.  I felt pain in the /hands/
and /fingers/.  I found a solution with [[https://github.com/abo-abo/hydra][hydra]].  I defined an ~hydra~
that contain the basic movements.  This alleviated my pain and changed
completly my way of using emacs.

From that moment, I stopped relying on the default key bindings and
always asking myself if I can find betters key bindings.  It leads to
exotic re-bindings that are not so easy to reconcile with some complete
and complex packages like ~magit~.  But in the long term, it seems to be a
good bet for me.

** Miscellaneous

#+BEGIN_SRC emacs-lisp
(pending-delete-mode t)
(setq-default truncate-lines t)
#+END_SRC

** Completion framework
I used ~ido~ as general completion framework and [[https://github.com/company-mode/company-mode][company-mode]] as code
completion.
** hydra
I had an hydra command for basic movements and another for sexp
operations.

I started using different cursor colors according to the /emacs
operation/ I perform.  This gives me an quick insight of the commands
I can perform without having to search the information neither in the
~mode-line~ nor in the ~echo-area~.

#+BEGIN_SRC emacs-lisp
(defun hydra-basics/pre ()
  (set-cursor-color "#ccc7c7"))

(defun hydra-basics/post ()
  (set-cursor-color "SteelBlue"))

(defhydra hydra-basics (:pre hydra-basics/pre :post hydra-basics/post)
  "emacs basics"
  ("f" forward-char)
  ("b" backward-char)
  ("n" next-line)
  ("p" previous-line)
  ("m" set-mark-command "mark")
  ("a" move-beginning-of-line "beg")
  ("e" move-end-of-line "end")
  ("k" kill-line "kill-line")
  ("cw" kill-region "kill-region")
  ("w" kill-ring-save "kill-ring-save")
  ("y" yank "yank")
  ("RET" newline "return")
  ("DEL" backward-delete-char-untabify "backspace")
  ("q" nil "quit"))

(defhydra hydra-smartparens ()
  "smartparens functions"
  ("f" sp-forward-sexp "forward")
  ("b" sp-backward-sexp "backward")
  ("n" sp-next-sexp "next")
  ("p" sp-previous-sexp "previous")
  (")" sp-up-sexp "up")
  ("(" sp-backward-up-sexp "backward-up")
  ("a" sp-beginning-of-sexp "beginning-of")
  ("e" sp-end-of-sexp "end-of")
  ("]" sp-down-sexp "down")
  ("[" sp-backward-down-sexp "backward-down")
  ("<down>" sp-beginning-of-next-sexp "beginning-of-next")
  ("<up>" sp-beginning-of-previous-sexp "beginning-of-previous")
  ("<right>" sp-end-of-next-sexp "end-of-next")
  ("<left>" sp-end-of-previous-sexp "end-of-previous")
  ("se" sp-splice-sexp "splice")
  ("sb" sp-splice-sexp-killing-backward "splice-killing-backward")
  ("sf" sp-splice-sexp-killing-forward "splice-killing-forward")
  ("r"  sp-raise-sexp "raise")
  ("m" sp-mark-sexp "mark")
  ("i" sp-change-inner "change-inner")
  ("u" sp-change-enclosing "change-enclosing")
  ("k" sp-kill-sexp "kill")
  ("DEL" sp-backward-kill-sexp "backward-kill")
  ("c" sp-copy-sexp "copy")
  ("@" sp-backward-copy-sexp "backward-copy")
  ("h" sp-kill-hybrid-sexp "kill-hybrid")
  ("l" sp-kill-whole-line "kill-whole-line")
  ("q" nil "quit"))
#+END_SRC

** Discarded Packages (in the setup)
I replaced [[https://github.com/auto-complete/auto-complete][auto-complete]] by [[https://github.com/company-mode/company-mode][company-mode]] (I didn't remember why).

| packages/modes | links         |
|----------------+---------------|
| ~auto-complete~  | [[https://github.com/auto-complete/auto-complete][auto-complete]] |
** New Packages (in the setup)
| packages/modes | links         |
|----------------+---------------|
| ~ace-jump-mode~  | [[https://github.com/winterTTr/ace-jump-mode][ace-jump-mode]] |
| ~ace-window~     | [[https://github.com/abo-abo/ace-window][ace-window]]    |
| ~company-mode~   | [[https://github.com/company-mode/company-mode][company-mode]]  |
| ~emmet-mode~     | [[https://github.com/smihica/emmet-mode][emmet-mode]]    |
| ~expand-region~  | [[https://github.com/magnars/expand-region.el][expand-region]] |
| ~iedit~          | [[https://github.com/victorhge/iedit][iedit]]         |
| ~smartparens~    | [[https://github.com/Fuco1/smartparens][smartparens]]   |
| ~web-mode~       | [[https://github.com/fxbois/web-mode][web-mode]]      |
| ~xah-css-mode~   | [[https://github.com/xahlee/xah-css-mode][xah-css-mode]]  |
** New commands (in the setup)
| commands                        | packages         |
|---------------------------------+------------------|
| ~capitalize-word~                 | built-in         |
| ~comment-dwim~                    | built-in         |
| ~delete-other-windows~            | built-in         |
| ~delete-window~                   | built-in         |
| ~downcase-region~                 | built-in         |
| ~downcase-word~                   | built-in         |
| ~enlarge-window-horizontally~     | built-in         |
| ~enlarge-window~                  | built-in         |
| ~isearch-backward~                | built-in         |
| ~isearch-forward~                 | built-in         |
| ~query-replace~                   | built-in         |
| ~scroll-left~                     | built-in         |
| ~scroll-right~                    | built-in         |
| ~shrink-window-horizontally~      | built-in         |
| ~shrink-window~                   | built-in         |
| ~upcase-region~                   | built-in         |
| ~upcase-word~                     | built-in         |
| ~ace-window~                      | [[https://github.com/abo-abo/ace-window][ace-window]]       |
| ~er/expand-region~                | [[https://github.com/magnars/expand-region.el][expand-region]]    |
| ~iedit-mode~                      | [[https://github.com/victorhge/iedit][iedit]]            |
| ~mc/mark-previous-like-this~      | [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]] |
| ~mc/mark-previous-like-this-word~ | [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]] |
** Custom commands

#+BEGIN_SRC emacs-lisp
(defun ta/comment-line ()
  (interactive)
  (save-excursion
    (beginning-of-line)
    (let ((beg (point)))
      (end-of-line)
      (setq end (point))
      (comment-or-uncomment-region beg end))))

(defun ta/kill-line-backward()
  (interactive)
  (kill-line 0))
#+END_SRC

** emacs-lisp
To write my own ~emacs~ commands, I started using the following
~variables~, ~functions~, ~macros~ and ~special forms~.
*** functions
- ~beginning-of-line~
- ~comment-or-uncomment-region~
- ~kill-line~
*** special forms
- ~let~
- ~save-excursion~
- ~setq~
* Step 2 (March 2019)
commit 6acc2ba7e3dfe835a8bf74c1914afbf0f0bb1ee1 (private repository).

I used ~emacs 24.5~.

At that moment, I had a version control of my ~emacs~ setup, but ~git~
was still new for me.  As a consequence, I don't know if there is
private information in the ~git~ history, so I didn't make it public.

It was new to me to write commits and so it is not so easy to follow
the flow of the modifications of my setup.  But I found the way to
extract some informations.

I used the default key bindings for movements ~C-b~, ~C-f~,
~C-p~, ~C-n~, ~C-a~, ~C-e~... and for almost any commands.

** UI
I used ~color-theme-comidia~ from ~color-theme~ package.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(column-number-mode t)
(global-linum-mode t)
(global-hl-line-mode)
#+END_SRC

** Completion framework
I used ~ido~ as general completion framework and [[https://github.com/auto-complete/auto-complete][auto-complete]] as code
completion.
** New packages (in the setup)
| packages/modes          | links            |
|-------------------------+------------------|
| ~abbrev-mode~             | built-in         |
| ~dired-hide-details-mode~ | built-in         |
| ~ibuffer~                 | built-in         |
| ~ido~                     | built-in         |
| ~shell~                   | built-in         |
| ~auto-complete~           | [[https://github.com/auto-complete/auto-complete][auto-complete]]    |
| ~multiple-cursors~        | [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]] |
| ~yasnippet~               | [[https://github.com/joaotavora/yasnippet][yasnippet]]        |
** New Commands (in the setup)
| commands                    | packages         |
|-----------------------------+------------------|
| ~ibuffer~                     | built-in         |
| ~replace-string~              | built-in         |
| ~mc/mark-next-like-this~      | [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]] |
| ~mc/mark-next-like-this-word~ | [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]] |
** Custom commands
I wrote some custom commands to open determined files in specific
layouts and to use the ~shell~.

#+BEGIN_SRC emacs-lisp
(defun ta/modify-ui-find-file-writing ()
  (interactive )
  (delete-other-windows)
  (split-window-right)
  (find-file "~/Documents/daily-writing.org")
  (other-window 1)
  (find-file "~/Documents/daily-videos.org")
  (other-window -1))

(defun ta/shell-window-below ()
  (interactive)
  (split-window-below -4)
  (other-window 1)
  (shell))
#+END_SRC
** emacs-lisp
To write my own ~emacs~ commands, I started using the following
~variables~, ~functions~, ~macros~ and ~special forms~.
*** functions
- ~delete-other-windows~
- ~find-file~
- ~get-buffer~
- ~goto-line~
- ~kill-buffer~
- ~mapcar~
- ~message~
- ~other-window~
- ~recenter-top-bottom~
- ~save-buffer~
- ~shell~
- ~split-window-below~
- ~split-window-right~
*** macros
- ~defun~
- ~when~
- ~with-current-buffer~
* Step 1 (April 2018 - Feb 2019)
In March 2018, I decided that I wanted to become *rich*, and I will do
it in the /Tech world/.  So, in April 2018, I started using ~emacs~,
everyday.  I had to restart almost from scratch, I mean, I had to do
the built-in ~emacs~ tutorial to get started.  At the same time I
started designing my [[https://github.com/tonyaldon/keyboard-layout][keyboard-layout]].

At the beginning, I didn't know ~git~ and ~github~.  So I didn't
think about making a version control of my ~emacs~ setup.

I don't remember exactly when, but at some point I started looking at
the ~emacs~ setups of [[https://github.com/magnars/.emacs.d][Magnar Sveen]] and [[https://github.com/hrs/dotfiles][Harry R. Schwartz]].
* Step 0 (April 2015 - March 2018)
I was introduced to ~emacs~ in April 2015 when I was doing an
intership at [[https://www.edf.fr/][EDF]] by Cyrille, an experienced
programmer, that answered to any questions about ~emacs~ and
~programming~ I had.  He was using a [[https://kinesis-ergo.com/][kinesis mechanical keyboard]],
running ~emacs~ on his smartphone and was really nice.

I spent 6 month using ~emacs~ to write ~R~ code and ~latex~ documents.
I worked on the ~R~ package [[https://cran.r-project.org/web/packages/clr/index.html][clr]] (clr: Curve Linear Regression via
Dimension Reduction).

Then from November 2015 to April 2016 I work as a data scientist where I
wrote ~python~ code in a young startup that doesn't survived.

During that year (April 2015 - April 2016) I've been using ~emacs~
with *no configuration at all* but a dark theme.

Then, from April 2016 to March 2018, I didn't work neither with
~emacs~ nor any other ~text editor~.  My work didn't involve much
using computers.
